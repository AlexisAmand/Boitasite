<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>SELFHTML: CGI/Perl / &Eacute;l&eacute;ments de langage Perl / Programmation orient&eacute;e sur l'objet</title>
<link rel="stylesheet" type="text/css" href="../../src/selfhtml.css">
<meta name="description"    content="Que d&eacute;signe la programmation orient&eacute;e sur l'objet et comment fontionne t-elle en Perl.">
<meta name="keywords"       content="SELFHTML, Perl, OOP, programmation orient&eacute;e sur l'objet, objets, classes, instances, propri&eacute;t&eacute;s m&eacute;thodes,  propri&eacute;t&eacute;s d'objet, donn&eacute;es d'objet, fonction construction, fonction destruction">
<meta name="author"         content="Stefan M&uuml;nz, selfhtml@teamone.de">
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta name="DC.Publisher"   content="Serge Fran&ccedil;ois, selfhtml@selfhtml.com.fr">
<meta name="DC.Date"        content="2003-01-27T08:00+00:00">
<meta name="DC.Identifier"  content="http://selfhtml.selfhtml.com.fr/cgiperl/langage/objets.htm">
<meta name="DC.Language"    content="fr">
<meta name="DC.Rights"      content="../../editorial/copyright.htm">
<meta name="DC.Date.Create" content="2003-01-27T08:00+00:00">
<meta name="SELF.Version"   content="1">
<meta name="SELF.Pagetype"  content="Information">
<meta name="SELF.Path"      content="SELFHTML == ../../index.htm // CGI/Perl == ../index.htm // &Eacute;l&eacute;ments de langage Perl == index.htm">
<!-- Matomo -->
<script type="text/javascript">
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//matomo.boitasite.com/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#AA5522" vlink="#772200" alink="#000000">

<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td bgcolor="#FFEEDD" class="nav"><a class="an" name="top"><img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"></a> <a href="../../index.htm"><b>SELFHTML</b></a>/<a href="../../navigation/index.htm" target="_parent">Aides &agrave; la navigation</a> <img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"> <a href="../index.htm"><b>CGI/Perl</b></a> <img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"> <a href="index.htm"><b>&Eacute;l&eacute;ments de langage Perl</b></a></td>
</tr>
</table><table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td bgcolor="#EEEEEE" class="doc" width="110"><img src="../../src/logo.gif" width="106" height="109" border="0" alt="SELFHTML"></td>
<td bgcolor="#EEEEEE" class="doc" valign="bottom" width="100%"><h2>Programmation orient&eacute;e sur l'objet</h2>
<tr>
<td bgcolor="#EEEEEE" class="doc" valign="top" align="center">
<img src="../../src/docx.gif" width="30" height="20" vspace="6" border="0" alt="Page d'information: vue d'ensemble">
</td>
<td bgcolor="#FFFFFF" valign="top" nowrap>
<p>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#oop"><b>Programmation orient&eacute;e sur l'objet (OOP)</b></a><br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#oop_perl"><b>Programmation orient&eacute;e sur l'objet en Perl</b></a><br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#exemple_htmlprint"><b>Exemple simple: l'objet HTMLprint</b></a><br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#exemple_vcard"><b>Exemple avec des donn&eacute;es d'objet: l'objet VCard</b></a><br>
</p>
</td>
</tr><tr><td colspan="2" bgcolor="#EEEEEE" class="doc">&#160;<a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;</td></tr>
</table>



<h2 class="Sh2"><a class="an" name="oop">Programmation orient&eacute;e sur l'objet (OOP)</a></h2>

<p>Il est important avant tout pour les projets de programmation plus importants de na pas se lancer t&ecirc;te baiss&eacute;e dans la programmation, mais de r&eacute;fl&eacute;chir auparavant &agrave; ce que l'application doit pouvoir faire, sous quelle forme elle doit sauvegarder les donn&eacute;es, quelles interfaces utilisateur sont indispensables etc... &Agrave; ce stade, il n'est pas du tout important, &agrave; vrai dire m&ecirc;me g&ecirc;nant, d'avoir sans arr&ecirc;t des bribes de code source qui trottent dans la t&ecirc;te. Il est pr&eacute;f&eacute;rable de modeler l'application &agrave; partir d'une r&eacute;flexion naturelle.</p>

<p>La r&eacute;flexion naturelle de l'homme moderne n'est aussi structur&eacute;e que la programmation classique. Elle ne pense pas en adresses de saut et en structure de contr&ocirc;le mais en unit&eacute;s propres plus importantes (les hommes, les machines etc...), en mesure de ma&icirc;triser les informations et les capacit&eacute;s de communiquer l'un avec l'autre pour cr&eacute;er quelque chose de nouveau.</p>

<p>M&ecirc;me un livre de visites bas&eacute; sur CGI se con&ccedil;oit de cette fa&ccedil;on. Il y a l&agrave; par exemple un gestionnaire de formulaires qui prend en charge l'&eacute;valuation des formulaires remplis, un gestionnaire de fichiers dont la t&acirc;che est de sauvegarder et de lire les donn&eacute;es de fa&ccedil;on fiable et homog&egrave;ne, et un gestionnaire de configuration qui d&eacute;cide quelles possibilit&eacute;s du livre de visites sont utilis&eacute;es dans un cas concret et sous quelle forme. Ici par exemple, le gestionnaire de configuration doit demander au gestionnaire de fichiers de lire certaines donn&eacute;es de configuration. De lui m&ecirc;me, il ne le peut pas, c'est le travail du gestionnaire de fichiers. Il est tout aussi impossible au gestionnaire de fichiers d'aller purement et simplement se chercher les formulaires HTML qui ont &eacute;t&eacute; envoy&eacute;s par l'utilisateur. Pour cela le gestionnaire de formulaire est habilit&eacute; qui devra peut &ecirc;tre demander au gestionnaire de configuration comment il doit transmettre les donn&eacute;es avant de les remettre au gestionnaire de fichiers pour &ecirc;tre sauvegard&eacute;es conform&eacute;ment &agrave; la r&eacute;ponse du gestionnaire de configuration.</p>

<p>Ces unit&eacute;s capables de collaborer sont d&eacute;sign&eacute;es comme objets dans la programmation orient&eacute;e sur l'objet. Un objet a des propri&eacute;t&eacute;s et peut faire quelque chose. Certaines des propri&eacute;t&eacute;s et capacit&eacute;s viennent d'autres objets que l'objet lui-m&ecirc;me a incorpor&eacute;s et dont il a ainsi h&eacute;rit&eacute; et d'autres &agrave; leur tour sont des propri&eacute;t&eacute;s et capacit&eacute;s tout &agrave; fait distinctes et particuli&egrave;res de cet objet.</p>

<p>Ceci n'est pas le cadre pour divulguer la th&eacute;orie de la programmation orient&eacute;e sur l'objet. Vous devez cependant conna&icirc;tre certains termes importants:</p>

<p><b>classe:</b><br>
Une classe est la somme des capacit&eacute;s programm&eacute;es d'un objet. Tout ce dont est constitu&eacute; un objet et ce qu'il peut faire doit &ecirc;tre programm&eacute; quelque part. Une classe est n&eacute;anmoins programm&eacute;e &quot;abstraitement&quot;, elle n'ex&eacute;cute aucun code. Ainsi que l'on a un certaine id&eacute;e de l'appareil si on pense &agrave; un &quot;r&eacute;cepteur  du monde &agrave; ondes courtes&quot;, un objet concret dans la programmation sur l'objet ne peut &ecirc;tre d&eacute;riv&eacute; que de sa classe. Un objet concret a les propri&eacute;t&eacute;s et les capacit&eacute;s de sa classe, ainsi que l'on dirait d'un r&eacute;cepteur  du monde &agrave; ondes courtes que l'on tient dans la main que c'est un r&eacute;cepteur  du monde &agrave; ondes courtes parce qu'il en  les propri&eacute;t&eacute;s et les fonctions et donc qu'il correspond &agrave; l'id&eacute;e qu'on se fait d'un r&eacute;cepteur  du monde &agrave; ondes courtes. Dans une application orient&eacute;e sur l'objet, vous pouvez dire: pour le travail que je d&eacute;sire r&eacute;soudre, j'ai d'abord besoin d'une classe d&eacute;termin&eacute;e, ainsi qu'on pourrait dire: pour ce travail j'ai besoin d'un r&eacute;cepteur  du monde &agrave; ondes courtes.</p>

<p><b>instance:</b><br>
Une instance est un objet concret d'une certaine classe. Avec le seul concept de  r&eacute;cepteur  du monde &agrave; ondes courtes vous ne pouvez toujours pas faire le moindre travail. Vous avez besoin d'un r&eacute;cepteur  du monde &agrave; ondes courtes bien r&eacute;el pour le faire. De la m&ecirc;me fa&ccedil;on, vous avez besoin de l'instance bien r&eacute;elle d'une classe pour que votre application orient&eacute;e sur l'objet r&eacute;alise un travail. Votre objet concret re&ccedil;oit un nom individuel sous lequel vous pouvez l'adresser.</p>

<p><b>Propri&eacute;t&eacute;s et m&eacute;thodes:</b><br>
Vous ne pouvez pas attendre plus d'une instance d'un objet que ce de quoi l'objet est capable en fonction de sa classe. Ce de quoi l'objet est capable est fix&eacute; par ce qui est programm&eacute; dans sa classe. Les propri&eacute;t&eacute;s (&eacute;galement nomm&eacute;es attributs) sont des variables que vous avez &agrave; votre disposition quand vous avez cr&eacute;&eacute; une instance d'un objet. Les m&eacute;thodes sont des fonctions qu'une instance d'un objet met &agrave; votre disposition. Une instance de la classe &quot;gestionnaire de formulaires&quot; pourrait par exemple mettre &agrave; disposition en tant que propri&eacute;t&eacute; une structure de donn&eacute;es  dans laquelle elle tient commod&eacute;ment &agrave; disposition les  donn&eacute;es de formulaires ayant &eacute;t&eacute; lues. Cette instance pourrait par exemple proposer des fonctions de filtre comme m&eacute;thodes, pour ne proposer par exemple que les donn&eacute;es des champs cach&eacute;s du formulaire. Sans votre application, vous pouvez utiliser les propri&eacute;t&eacute;s et les m&eacute;thodes en &quot;pointant&quot; sur leur nom dans une instance concr&egrave;te. C'est comme si, lorsque vous avez un r&eacute;cepteur  du monde &agrave; ondes courtes dans les mains, vous vous actionniez la fonction (une m&eacute;thode) &quot;recherche l'&eacute;metteur suivant qui soit suffisamment puissant&quot; et que pour l'&eacute;metteur ainsi trouv&eacute;, vous puissiez en lire la fr&eacute;quence sur le cadran (une propri&eacute;t&eacute;).</p>

<p><b>Fonctions destruction et construction:</b><br>
Un fonction construction prend en charge la fa&ccedil;on de cr&eacute;er une instance d'un objet. Dans une certaine mesure, elle fait du concept du r&eacute;cepteur du monde &agrave; ondes courtes,  un r&eacute;cepteur du monde &agrave; ondes courtes bien r&eacute;el. Maintenant que vous l'avez avec vous, &agrave; un moment ou &agrave; un autre vous n'aurez plus besoin du r&eacute;cepteur  du monde &agrave; ondes courtes. Alors il devient un bagage inutile. C'est la raison pour laquelle vous pouvez alors le d&eacute;truire. C'est judicieux tout au moins dans l'ordinateur car cela permet de lib&eacute;rer des ressources m&eacute;moire. Pour d&eacute;truire des instances d'objet, il existe une fonction destruction.</p>



<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="oop_perl">Programmation orient&eacute;e sur l'objet en Perl</a></h2>

<p>L'interpr&eacute;teur Perl soutient la programmation orient&eacute;e sur l'objet depuis la version  5.0. Pour programmer une classe, donc ce de quoi d&eacute;rive une instance d'objet, vous avez besoin en Perl d'un  <b>Package</b> (progiciel) distinct, &agrave; savoir d'un espace de nommage distinct. Les <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="sousroutines.htm"><b>sous-programmes</b></a>, qui sont not&eacute;s dans le progiciel sont des m&eacute;thodes des objets de cette classe. Vous pouvez m&ecirc;me d'une certaine fa&ccedil;on d&eacute;finir des propri&eacute;t&eacute;s d'objet &agrave; l'int&eacute;rieur de ces m&eacute;thodes. Les packages peuvent certes &ecirc;tre d&eacute;finis dans un fichier Perl (voir l'exemple sur la fonction  Perl <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../fonctions/modules.htm#package"><b>package</b></a>), mais normalement un package est un fichier Perl s&eacute;par&eacute; qui n'a pas d'autre vocation que d'&ecirc;tre &quot;incorpor&eacute;&quot; dans des scripts Perl. En bref: un package est en Perl la plupart du temps un  <img src="../../src/chap.gif" width="15" height="13" border="0" alt="Chapitre: vue d'ensemble">&nbsp;<a href="../modules/index.htm"><b>module</b></a> avec l'extension de fichier correspondante <code>.pm</code>. &Agrave; partir de l&agrave; la programmation orient&eacute;e sur les modules et la programmation orient&eacute;e sur l'objet sont en Perl &eacute;troitement li&eacute;es.</p>

<p>N&eacute;anmoins un package n'est pas pour autant automatiquement une classe pour les objets. Les packages sont en fin de compte des espaces de nommage et par l&agrave; m&ecirc;me l'&quot;environnement dans lequel les classes d'objet peuvent prosp&eacute;rer&quot;. Pour que Perl reconnaisse une classe pour objets en tant que telle, elle doit &ecirc;tre cr&eacute;&eacute;e et d&eacute;finie comme telle.

<p>Il en va de m&ecirc;me avec les instances objets. Vous devez d'abord faire savoir &agrave; Perl que vous d&eacute;sirez cr&eacute;er une instance objet. Quand c'est fait, vous pouvez ensuite adresser les propri&eacute;t&eacute;s et m&eacute;thodes de cet objet par une syntaxe d&eacute;termin&eacute;e.</p>

<h3 class="inf">Attention:</h3>

<p>Perl propose &eacute;galement d'autres propri&eacute;t&eacute;s de la programmation orient&eacute;e sur l'objet, par exemple l'h&eacute;ritage et la liaison de m&eacute;thodes &agrave; des variables. Ces autres propri&eacute;t&eacute;s ne sont cependant pas trait&eacute;es dans cette introduction.</p>




<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="exemple_htmlprint">Exemple simple: l'objet HTMLprint</a></h2>

<p>Il est montr&eacute; dans cet exemple comment vous &eacute;tablissez un module en tant que classe d'objet, cr&eacute;ez une instance de cet objet dans un script Perl, et travaillez avec les m&eacute;thodes de cet objet. L'exemple r&eacute;alise un simple objet pour des sorties HTML dans le navigateur.</p>

<h3 class="xmp">Exemple du fichier module <var>HTMLprint.pm</var>:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
package HTMLprint;

sub new {
 my $objet = shift;
 my $reference = {};
 bless($reference,$objet);
 return($reference);
}

sub commencement {
  my $objet = shift;
  my $titre = shift;
  print &quot;Content-type: text/html\n\n&quot;;
  print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
  print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;$titre&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n&quot;;
}

sub titre {
  my $objet = shift;
  my $texte_sorti = shift;
  print &quot;&lt;h1&gt;$texte_sorti&lt;/h1&gt;\n&quot;;
}

sub texte {
  my $objet = shift;
  my $texte_sorti = shift;
  print &quot;&lt;p&gt;$texte_sorti&lt;/p&gt;\n&quot;;
}

sub fin {
  my $objet = shift;
  print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
}

1;
</pre></td></tr></table>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);
use HTMLprint;

my $html = HTMLprint -&gt; new();
$html-&gt;commencement(&quot;Perl tout � fait �l�gant&quot;);
$html-&gt;titre(&quot;Perl tout � fait �l�gant&quot;);
$html-&gt;texte(&quot;HTML mis�rable mais programm� de fa&ccedil;on tr�s moderne!&quot;);
$html-&gt;fin();

</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>Le fichier module commence simplement avec une instruction <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../fonctions/modules.htm#package"><b>package</b></a> qui donne le nom du module. Le nom doit &ecirc;tre identique &agrave; celui du module sans extension. Si le fichier module donc s'appelle comme dans l'exemple <var>HTMLprint.pm</var>, l'instruction doit alors &ecirc;tre <code>package&nbsp;HTMLprint;</code>.</p>

<p>Le fichier module de l'exemple contient au total cinq sous-programmes. Le premier d'entre eux est la fonction construction. Elle re&ccedil;oit habituellement le nom <code>new</code>, mais pourrait aussi th&eacute;oriquement recevoir un autre nom. Comment est b&acirc;tie le fonction construction peut varier d'un cas &agrave; l'autre. Dans tous les cas, la fonction construction doit contenir un appel de la fonction <code>bless</code> . Celle-ci lie une r&eacute;f&eacute;rence &agrave; une classe, de fa&ccedil;on &agrave; ce qu'ensuite il puisse &ecirc;tre acc&eacute;d&eacute; &agrave; cet objet par cette r&eacute;f&eacute;rence. La fonction construction montr&eacute;e dans l'exemple ci-dessus en fait certes d&eacute;j&agrave; un peu plus qu'il n'est n&eacute;cessaire &agrave; l'exemple, mais est cependant bien appropri&eacute;e sous cette forme comme fonction de construction standard avec laquelle on ne peut pas faire grand chose de faux.</p>

<p>Avec <code>my $objet = shift;</code> le premier param&egrave;tre que la fonction de construction <code>new</code> se voit transmettre, est simplement lu. Elle re&ccedil;oit &agrave; vrai dire comme premier param&egrave;tre transmis quand elle est appel&eacute;e automatiquement le nom de classe, dans l'exemple donc le nom  <code>HTMLprint</code>. C'est dans l'exemple la valeur qui figure ensuite dans <code>$objet</code>.<br>
Avec <code>my $reference = {};</code> une <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="references.htm"><b>r&eacute;f&eacute;rence</b></a>, est d&eacute;clar&eacute;e &agrave; savoir un pointeur. Ce pointeur est n&eacute;cessaire pour que la fonction <code>bless</code> puisse &ecirc;tre utilis&eacute;e correctement et puisse lier le pointeur &agrave; l'objet. Maintenant se pose la question comment faire de la variable scalaire <code>$reference</code> une r&eacute;f&eacute;rence. Il faut bien qu'elle se r&eacute;f&egrave;re &agrave; ce qu'elle d&eacute;signe. L'affectation <code>{}</code> est id&eacute;ale pour le faire. C'est simplement une r&eacute;f&eacute;rence &agrave; un <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="hashes.htm"><b>Hash</b></a> vide et sans nom. C'est id&eacute;al pour la simple raison que ce hash est &eacute;galement appropri&eacute; pour la d&eacute;finition des donn&eacute;es d'objet, ce qui n'est de toutes fa&ccedil;ons pas encore le cas dans ce premier exemple simple. Ainsi on en reste au hash vide et  <code>$reference</code> est un pointeur.<br>
Avec <code>bless($reference,$objet);</code> la liaison n&eacute;cessaire entre la r&eacute;f&eacute;rence et l'objet est r&eacute;alis&eacute;e. Ensuite <code>$reference</code> est retourn&eacute;e.</p>

<p>Les quatre autres sous-programmes dans le fichier module <var>HTMLprint.pm</var> sont tous tr&egrave;s semblables. Ils cr&eacute;ent &agrave; l'aide d'instructions <code>print</code> du code HTML. Le sous-programme <code>commencement</code> &eacute;crit d'abord l'ent&ecirc;te HTTP n&eacute;cessaire pour les sorties HTML &agrave; un  navigateur appelant.</p>

<p>Pour tous les sous-programmes qui fonctionnent comme m&eacute;thodes d'un objet, s'applique ceci: ils se voient transmettre au moins un param&egrave;tre, &agrave; savoir le pointeur sur l'objet qui a &eacute;t&eacute; cr&eacute;&eacute; et li&eacute; &agrave; l'objet dans la fonction de construction. Les sous-programmes de l'exemple n'ont pas besoin de ce pointeur. Mais <code>commencement</code>, <code>titre</code> et <code>texte</code> attendent encore un deuxi&egrave;me param&egrave;tre tout &agrave; fait ordinaire, &agrave; savoir le contenu qu'ils doivent sortir en HTML. Maintenant, les sous-programmes peuvent se chercher &eacute;galement le contenu de ce deuxi&egrave;me param&egrave;tre directement avec <code>$_[1]</code>. Mais la notation avec l'appel de la fonction <code>shift</code> pr&eacute;sente l'avantage de traiter proprement et dans l'ordre la liste de param&egrave;tres en les effa&ccedil;ant apr&egrave;s traitement. Avec le deuxi&egrave;me appel respectif de <code>shift</code> les trois sous-programmes mentionn&eacute;s acc&egrave;dent donc au deuxi&egrave;me param&egrave;tre.</p>

<p>Il est encore important de mentionner que les fichiers module <var>pm</var> doivent toujours contenir &agrave; la fin une instruction isol&eacute;e <code>1;</code> (ou quelque chose de similaire). Cela signifie que le fichier module renvoie une valeur vrai. Faute de quoi l'interpr&eacute;teur Perl annoncerait une erreur.</p>


<p>Le script Perl proprement dit dans l'exemple est &agrave; vrai dire tout &agrave; fait simple. Avec la fonction <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../fonctions/modules.htm#use"><b>use</b></a> et l'instruction <code>use&nbsp;HTMLprint;</code> il incorpore le fichier module <var>HTMLprint.pm</var>. Incorpor&eacute; sous cette forme, le fichier <var>HTMLprint.pm</var> doit se trouver soit dans le m&ecirc;me r&eacute;pertoire que le script ou bien dans l'un des r&eacute;pertoires centraux dans lesquels Perl recherche les modules (de plus amples d&eacute;tails &agrave; ce sujet dans la partie traitant de l'<img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../modules/intro.htm#lieux_sauvegarde_inc"><b>emplacement de sauvegarde des modules et de la liste @INC</b></a>).</p>

<p>Avec <code>my $html = HTMLprint -> new();</code> la fonction de construction du fichier module est appel&eacute;e. C'est l'instruction d&eacute;terminante avec laquelle une nouvelle instance de l'objet HTMLprint est cr&eacute;&eacute;e! L'instruction consiste &agrave; d&eacute;clarer une scalaire qui dans l'exemple re&ccedil;oit pour nom  <code>$html</code>, et &agrave; l'initialiser avec une valeur. La valeur affect&eacute;e consiste &agrave; faire pointer le nom de la classe d'objet d&eacute;sir&eacute;e donc <code>HTMLprint</code>, &agrave; l'aide de l'op&eacute;rateur fl&egrave;che <code>-&gt;</code> sur la fonction de construction <code>new</code>. &Eacute;tant donn&eacute; que la fonction de construction renvoie une r&eacute;f&eacute;rence qui est li&eacute;e &agrave; l'objet par l'appel de <code>bless</code>, <code>$html</code> est automatiquement une r&eacute;f&eacute;rence, donc un pointeur sur l'instance objet nouvellement cr&eacute;&eacute;e. Par <code>$html</code> et l'op&eacute;rateur fl&egrave;che <code>-&gt;</code> peut continuer &agrave; acc&eacute;der aux sous-programmes du module incorpor&eacute;. Dans le contexte objets, on ne parle n&eacute;anmoins plus de sous-programmes mais de m&eacute;thodes.<br>
Avec une instruction telle que <code>$html-&gt;commencement(&quot;Perl tout &agrave; fait &eacute;l&eacute;gant&quot;);</code> le script acc&egrave;de donc &agrave; une m&eacute;thode de l'objet <code>HTMLprint</code>, &agrave; savoir &agrave; l'instance de l'objet li&eacute;e au pointeur <code>$html</code>.</p>





<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="exemple_vcard">Exemple avec des donn&eacute;es d'objet: l'objet VCard</a></h2>

<p>L'exemple suivant montre comment des donn&eacute;es se laissent g&eacute;rer avec des objets. Il s'agit ici de donn&eacute;es d'adresses dans le format standard international VCard  (extension typique de fichier: *.vcf), tel qu'il est d&eacute;velopp&eacute; par l'<img src="../../src/en.gif" width="16" height="10" border="0" alt="Page en langue anglaise">&nbsp;<a target="_top" href="http://www.imc.org/"><b>Internet Mail Consortium (IMC)</b></a>. Dans le fichier module <var>VCard.pm</var> sont d&eacute;finies la classe VCard ainsi que les donn&eacute;es d'objet et les m&eacute;thodes. Dans le script principal, deux instances objet de cette classe sont d&eacute;finies et les m&eacute;thodes de l'objet sont essay&eacute;es.</p>


<h3 class="xmp">Exemple du fichier module <var>VCard.pm</var>:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
package VCard;

$objets = 0;

sub new {
 my $objet = shift;
 my $Version = shift;
 my $reference = {};
 bless($reference,$objet);
 $objets += 1;
 $reference-&gt;VCinit($Version);
 return($reference);
}

sub VCinit {
  my $objet = shift;
  my $Version = shift;
  $objet-&gt;{BEGIN} = &quot;VCARD&quot;;
  $objet-&gt;{VERSION} = $Version;
  $objet-&gt;{END} = &quot;VCARD&quot;;
}

sub VCset {
  my $objet = shift;
  my $clef = shift;
  my $valeur = shift;
  $objet-&gt;{$clef} = $valeur;
}

sub VCget {
  my $objet = shift;
  my $clef = shift;
  return($objet-&gt;{$clef});
}

sub VCsave {
  my $objet = shift;
  my $fichier = shift;
  open(FICHIER, &quot;&gt;$fichier&quot;) or return(-1);
  print FICHIER &quot;BEGIN:VCARD\nVERSION:$objet-&gt;{VERSION}\n&quot;;
  while ((my $clef, my $valeur) = each %{ $objet } ) {
    next if ($clef eq 'BEGIN' or $clef eq 'VERSION' or $clef eq 'END');
    $clef =~ s/_/\;/g;
    print FICHIER &quot;$clef:$valeur\n&quot;;
  }
  print FICHIER &quot;END:VCARD\n&quot;;
  close(FICHIER);
  return($fichier);
}

sub VCopen {
  my $objet = shift;
  my $fichier = shift;
  $objet-&gt;VCreset();
  open(FICHIER, &quot;&lt;$fichier&quot;) or return;
  my @lignes = &lt;FICHIER&gt;;
  close(FICHIER);
  foreach (@lignes) {
   (my $clef, my $valeur) = split(/:/);
    $clef =~ s/\;/_/g;
    $objet-&gt;{$clef} = $valeur;
  }
  return( %{ $objet } );
}

sub VCreset {
  my $objet = shift;
  %{ $objet } = ();
}

1;
</pre></td></tr></table>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);
use VCard;

print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n&quot;;
print &quot;&lt;h1&gt;Tests avec l'objet VCard&lt;/h1&gt;\n&quot;;

my $Thomas = VCard-&gt;new(&quot;2.1&quot;);
my $Delphine = VCard-&gt;new(&quot;2.1&quot;);

print &quot;&lt;p&gt;&lt;b&gt;Valeur de la propri&amp;eacute;t&amp;eacute; d'objet BEGIN cr&amp;eacute;&amp;eacute;e dans le module:&lt;/b&gt; $Delphine-&gt;{BEGIN}&lt;br&gt;\n&quot;;
my $Sauvegarde = $Delphine-&gt;{BEGIN};
$Delphine-&gt;{BEGIN} = &quot;Commen&amp;ccedil;ons&quot;;
print &quot;&lt;b&gt;BEGIN apr&amp;egrave;s la modification de valeur:&lt;/b&gt; $Delphine-&gt;{BEGIN}&lt;br&gt;\n&quot;;
$Delphine-&gt;{BEGIN} = $Sauvegarde;
print &quot;&amp;Eacute;tant donn&amp;eacute; que cela n'a pas grand sens,
la valeur a &amp;eacute;t&amp;eacute; fix&amp;eacute;e &amp;agrave; '$Delphine-&gt;{BEGIN}'.&lt;/p&gt;\n&quot;;

$Thomas-&gt;VCset(&quot;FN&quot;,&quot;Thomas Thuvu&quot;);
$Thomas-&gt;VCset(&quot;TEL_CELL_VOICE&quot;,&quot;(0170) 398373740&quot;);
$Delphine-&gt;VCset(&quot;FN&quot;,&quot;Delphine Naliste&quot;);
$Delphine-&gt;VCset(&quot;EMAIL_PREF_INTERNET&quot;,&quot;naliste\@football.org&quot;);

print &quot;&lt;p&gt;&lt;b&gt;Nom:&lt;/b&gt; &quot;,$Thomas-&gt;VCget('FN'),&quot;&lt;br&gt;\n&quot;;
print &quot;&lt;b&gt;Handy:&lt;/b&gt; &quot;,$Thomas-&gt;VCget('TEL_CELL_VOICE'),&quot;&lt;/p&gt;\n&quot;;
print &quot;&lt;p&gt;&lt;b&gt;Nom:&lt;/b&gt; &quot;,$Delphine-&gt;VCget('FN'),&quot;&lt;br&gt;\n&quot;;
print &quot;&lt;b&gt;Portable:&lt;/b&gt; &quot;,$Delphine-&gt;VCget('EMAIL_PREF_INTERNET'),&quot;&lt;/p&gt;\n&quot;;
print &quot;&lt;p&gt;&lt;b&gt;Nombre d'objets d�finis:&lt;/b&gt; $VCard::objets &lt;/p&gt;\n&quot;;


if(my $fichier = $Thomas-&gt;VCsave(&quot;/donnees/vcard/thuvu.vcf&quot;)) {
 print &quot;&lt;p&gt;VCard de Thomas Thuvu est sauvegard� dans &lt;tt&gt;$fichier&lt;/tt&gt;!&lt;br&gt;&quot;
}
else {
 print &quot;VCard de Thomas Thuvu n'a pas pu &amp;ecirc;tre sauvegard&amp;eacute;!&quot;;
}
$Thomas-&gt;VCreset();
print &quot;&lt;p&gt;&lt;b&gt;Nom de Thomas apr&amp;egraves initialisation de l'objet:&lt;/b&gt; &quot;,$Thomas-&gt;VCget('FN'),&quot;&lt;br&gt;\n&quot;;
print &quot;&lt;b&gt;Portable de Thomas apr&amp;egraves initialisation de l'objet:&lt;/b&gt; &quot;,$Thomas-&gt;VCget('TEL_CELL_VOICE'),&quot;&lt;/p&gt;\n&quot;;

if($Thomas-&gt;VCopen(&quot;/donnees/vcard/thuvu.vcf&quot;)) {
 print &quot;VCard de Thomas Thuvu est &amp;agrave; nouveau ouvert!&lt;br&gt;&quot;;
 print &quot;&lt;p&gt;&lt;b&gt;Nom de Thomas apr&amp;egraves l'ouverture du fichier:&lt;/b&gt; &quot;,$Thomas-&gt;VCget('FN'),&quot;&lt;br&gt;\n&quot;;
 print &quot;&lt;b&gt;Portable de Thomas apr&amp;egraves l'ouverture du fichier:&lt;/b&gt; &quot;,$Thomas-&gt;VCget('TEL_CELL_VOICE'),&quot;&lt;/p&gt;\n&quot;;
}
else {
 print &quot;VCard von Thomas Thuvu n'a pas pu &amp;ecirc;tre ouvert!&quot;;
}

print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xmp">Exemple du fichier cr&eacute;&eacute; <var>thuvu.vcf</var>:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
BEGIN:VCARD
VERSION:2.1
TEL;CELL;VOICE:(0170) 398373740
FN:Thomas Thuvu
END:VCARD
</pre></td></tr></table>





<h3 class="xpl">Explication:</h3>

<p>Sur le principe, cet exemple fonctionne exactement comme l'exemple avec l'<img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#exemple_htmlprint"><b>objet HTMLprint</b></a> - c'est pourquoi ne sont int&eacute;ressantes ici que les choses qui diff&egrave;rent du premier exemple.</p>

<p>Les donn&eacute;es d'objet (ou les propri&eacute;t&eacute;s d'un objet) sont des variables. Il ne suffit pourtant pas de d&eacute;clarer simplement ces variables n'importe o&ugrave; dans le fichier module. Une variable comme la scalaire <code>$objets</code>, qui dans l'exemple est d&eacute;clar&eacute;e au d&eacute;but du fichier module <var>VCard.pm</var> et qui sert de compteur pour les instances objets, <b>ne</b> fait <b>pas</b> partie des donn&eacute;es d'objet! Ces variables sont ce qu'on appelle des variables de classe, &eacute;tant donn&eacute; qu'elles ne sont disponibles qu'une fois pour la classe compl&egrave;te et pour chaque instance objet. &Eacute;tant donn&eacute; que le module est incorpor&eacute; exactement une fois dans le script principal, ces variables ne sont &eacute;galement disponibles que dans une seule ex&eacute;cution. Le script principal peut tout &agrave; fait avec la syntaxe <code>$VCard::objets</code> acc&eacute;der &agrave; la valeur de la scalaire <code>$objets</code>. Mais cette variable ne fait pas partie pour autant de l'objet. Les donn&eacute;es d'objet sont davantage celles qui &agrave; chaque nouvelle instance d'un objet sont &agrave; nouveau disponibles.</p>

<p>La solution la plus simple pour les donn&eacute;es d'objet est la  <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="hashes.htm"><b>Hash</b></a>. Dans la fonction de construction <code>new</code> un tel hash est d&eacute;fini - avec l'instruction <code>my&nbsp;$reference&nbsp;=&nbsp;{};</code>. On ne voit pas grand chose du hash ici. Cependant les parenth&egrave;ses accolades vides symbolise un hash vide que l'on dit anonyme. Ce hash est une esp&egrave;ce de conteneur vide qui pourra plus tard enregistrer les donn&eacute;es d'objet. La raison pour laquelle on choisit un hash en r&egrave;gle g&eacute;n&eacute;rale pour les donn&eacute;es d'objet, est que le hash peut sauvegarder un nombre dynamique de donn&eacute;es. Un tel hash permet de pr&eacute;d&eacute;finir des donn&eacute;es d'objet aussi bien dans le module lui-m&ecirc;me que dans le script principal (les deux cas sont expos&eacute;s dans l'exemple ci-dessus). Un Array le pourrait certes th&eacute;oriquement aussi mais la recherche de la date objet d&eacute;sir&eacute;e dans le script principal serait ensuite plus compliqu&eacute;e. Les hashes facilitent l'acc&egrave;s direct aux donn&eacute;es par la cl&eacute; nomm&eacute;e. Par l'affectation du hash anonyme &agrave; une scalaire - dans l'exemple &agrave; <code>$reference</code> - cette scalaire est une <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="references.htm"><b>r&eacute;f&eacute;rence</b></a>, donc un pointeur sur le hash anonyme. Par ce pointeur l'acc&egrave;s au hash anonyme est rendu possible.</p>

<p>Les donn&eacute;es d'objet sont cr&eacute;&eacute;es en remplissant dans un premier temps le hash anonyme de la fonction de construction avec des donn&eacute;es. Dans l'exemple, cela se fait d'abord dans le sous-programme ou plut&ocirc;t la m&eacute;thode <code>VCinit</code>. Cette m&eacute;thode est d&eacute;j&agrave; appel&eacute;e dans la fonction de construction <code>new</code>, &agrave; savoir avec <code>$reference->VCinit($Version);</code>. Comme dans la fonction de construction <code>$reference</code> est le pointeur d'objet, vous pouvez y appeler d'autres sous-programmes selon le sch&eacute;ma <code>$reference->Methode()</code>; ils seront ainsi li&eacute;s &agrave; l'objet. Par cette forme d'appel les sous programmes re&ccedil;oivent aussi toujours automatiquement comme premier param&egrave;tre transmis, un pointeur sur l'objet, avec lequel elles peuvent ensuite travailler. Il en va de m&ecirc;me pour la m&eacute;thode <code>VCinit</code> de l'exemple. Par le pointeur d'objet qu'elle va se chercher dans la liste des param&egrave;tres transmis avec <code>my $objet = shift;</code>, elle peut ensuite acc&eacute;der &agrave; l'objet et &eacute;galement par l&agrave; m&ecirc;me au hash anonyme.</p>

<p>Avec une instruction telle que <code>$objet-&gt;{BEGIN} = &quot;VCARD&quot;;</code> une propri&eacute;t&eacute; d'objet est cr&eacute;&eacute;e. <code>$objet-&gt;{BEGIN}</code> pointe sur le hash anonyme et revient &agrave; dire: &quot;Ainsi le hash anonyme re&ccedil;oit une cl&eacute; du nom de <code>BEGIN</code>&quot;. Par ailleurs, une valeur a d&eacute;j&agrave; &eacute;t&eacute; affect&eacute;e &agrave; cette cl&eacute;, &agrave; savoir <code>VCARD</code>. De la m&ecirc;me mani&egrave;re trois propri&eacute;t&eacute;s d'objet en tout sont cr&eacute;&eacute;es dans <code>VCinit</code>. Les deux autres s'appellent <code>VERSION</code> et <code>END</code>. La raison pour ces noms est dans l'exemple que celui-ci utilise comme noms de cl&eacute; les noms de propri&eacute;t&eacute;s qu'un fichier du type  <var>.vcf</var> peut contenir. &Agrave; quoi un tel fichier ressemble, c'est ce que vous voyez dans le fichier <var>thuvu.vcf</var> .  Chaque ligne d'un fichier  VCard comporte une propri&eacute;t&eacute; et sa valeur s&eacute;par&eacute;es par deux points. Trois lignes doivent figurer dans chaque fichier vcf: <code>BEGIN:VCARD</code>, <code>VERSION:[mention de version]</code> et <code>END:VCARD</code>. Pour ces trois lignes standard, sont cr&eacute;&eacute;es dans l'exemple trois propri&eacute;t&eacute;s d'objet du m&ecirc;me nom.</p>

<p>D'autres propri&eacute;t&eacute;s d'objet sont cr&eacute;&eacute;es dans le script principal de l'exemple. Tout d'abord il faut &agrave; nouveau pour le faire cr&eacute;er une instance de la classe VCard. Dans l'exemple deux instances sont cr&eacute;&eacute;es:<br>
<code>my $Thomas = VCard-&gt;new(&quot;2.1&quot;);<br>
my $Delphine = VCard-&gt;new(&quot;2.1&quot;);</code>
&Agrave; l'appel de la fonction de construction, le num&eacute;ro de version pour le format  VCard d&eacute;sir&eacute; est transmis. Pour l'heure les versions 2.1 et 3.0 ont cours.<br>
Apr&egrave;s que les deux instances d'objet sont cr&eacute;&eacute;es, l'acc&egrave;s &agrave; toutes les donn&eacute;es d'objet est possible. Dans le script principal, c'est ce qui est d'abord d&eacute;montr&eacute; avec l'objet pour Delphine. Par le pointeur d'objet <code>$Delphine</code> il est possible, avec <code>$Delphine-&gt;{BEGIN}</code> d'acc&eacute;der &agrave; la propri&eacute;t&eacute; d'objet <code>BEGIN</code>. Le script montre aussi comment une telle propri&eacute;t&eacute; d'objet peut &ecirc;tre modifi&eacute;e. La construction <code>$Delphine-&gt;{BEGIN}</code> peut &ecirc;tre trait&eacute;e comme une scalaire tout &agrave; fait normale.<br>
Comme pour la programmation orient&eacute;e sur l'objet, celui-ci est une entit&eacute; abstraite dont le contenu ne vous concerne &agrave; vrai dire en rien en tant qu'utilisateur, vous devez renoncer &agrave; acc&eacute;der directement aux propri&eacute;t&eacute;s d'objet. D'abord rien ne dit que pour un objet (quelconque) les donn&eacute;es seront tenues dans un hash et ensuite, la tenue de ces donn&eacute;es peut varier avec l'&eacute;volution des diff&eacute;rentes versions du module.</p>

<p>Le script principal cr&eacute;e aussi encore d'autres nouvelles propri&eacute;t&eacute;s d'objet en leur donnant une valeur. Car un fichier VCard doit bien contenir diff&eacute;rentes donn&eacute;es d'adresse. Cela est possible dans l'exemple par l'appel de la m&eacute;thode <code>VCset</code>, d&eacute;finie dans le fichier module. Avec une instruction comme:<br>
<code>$Thomas-&gt;VCset(&quot;FN&quot;,&quot;Thomas Thuvu&quot;);</code><br>
une nouvelle propri&eacute;t&eacute; d'objet nomm&eacute;e <code>FN</code> est cr&eacute;&eacute;e pour l'objet de Thomas, et re&ccedil;oit la valeur <code>Thomas Thuvu</code>. Dans l'exemple, vous voyez que tant l'objet de Thomas que l'objet de Delphine re&ccedil;oivent la propri&eacute;t&eacute; d'objet <code>FN</code>, chacun avec sa valeur propre. On peut tr&egrave;s bien y reconna&icirc;tre qu'il s'agit effectivement de diff&eacute;rentes instances de l'objet <code>VCard</code>, et que chaque instance a son propre ensemble de donn&eacute;es sans qu'il y ait de collision avec d'autres instances de l'objet existant en m&ecirc;me temps-.</p>

<p>Tandis que l'appel de la m&eacute;thode <code>VCset</code> peut &ecirc;tre &agrave; peu pr&egrave;s bien retrac&eacute;, ce qui se passe dans le fichier module &agrave; l'int&eacute;rieur de cette m&eacute;thode, n'est pas si facile &agrave; comprendre. <code>VCset</code> - comme toutes les m&eacute;thodes - re&ccedil;oit automatiquement comme premier param&egrave;tre transmis le pointeur d'objet. <code>VCset</code> ne fait rien d'autre qu'ins&eacute;rer un nom de cl&eacute; et sa valeur dans le hash anonyme avec <code>$objet-&gt;{$clef}&nbsp;=&nbsp;$valeur</code>. Tous deux donc  le nom de cl&eacute; et sa valeur, sont attendus comme param&egrave;tres par la m&eacute;thode - ce qui explique les instructions qui pr&eacute;c&egrave;dent telles que <code>$clef&nbsp;=&nbsp;shift;</code>. Les appels de cette m&eacute;thode dans le script principal transmettent aussi les deux param&egrave;tres requis.</p>

<p>Les autres m&eacute;thodes du fichier module sont construites de fa&ccedil;on tr&egrave;s similaires. Elles prennent en charge diff&eacute;rentes t&acirc;ches que l'on peut envisager avec des donn&eacute;es adresse:<br>
<code>VCget</code> donne la valeur correspondant &agrave; une cl&eacute;. Pratique pour des requ&ecirc;tes. Pour &ecirc;tre pr&eacute;cis une requ&ecirc;te telle que <code>$Thomas-&gt;VCget('FN')</code> dans le script principal revient au m&ecirc;me que s'il y figurait. <code>$Thomas-&gt;{FN}</code>. Quant &agrave; savoir si on a besoin de ces m&eacute;thodes rel&egrave;ve simplement de la conception d'un objet. Pour faciliter la maintenance du programme, vous devez cependant toujours mettre &agrave; disposition des m&eacute;thodes &agrave; cet effet.<br>
<code>VCsave</code> sauvegarde les donn&eacute;es d'un objet dans un fichier .vcf et d'apr&egrave;s le standard VCF. Dans le script cette fonction est appel&eacute;e une fois pour &eacute;crire le fichier <var>thuvu.vcf</var>, dont le contenu est repr&eacute;sent&eacute;.<br>
<code>VCopen</code> lit un fichier VCF quelconque et sauvegarde son contenu dans l'objet affect&eacute;. Vous pouvez donc utiliser cette m&eacute;thode quand vous avez des fichiers VCF existants, par exemple par l'exportation &agrave; partir des donn&eacute;es adresse d'un programme de courrier &eacute;lectronique compatible VCard.
<code>VCreset</code> efface toutes les donn&eacute;es d'un objet. Cette m&eacute;thode r&eacute;tablit donc l'&eacute;tat d'origine du hash anonyme. Cette m&eacute;thode est n&eacute;cessaire dans le fichier module dans <code>VCopen</code>. Mais vous pouvez naturellement aussi appeler cette m&eacute;thode dans le script principal pour mettre une instance d'objet dans son &eacute;tat vierge. Dans le script principal de l'exemple ci dessus, la d&eacute;monstration en est faite sur l'objet de Thomas.</p>

<p>Si vous voulez utiliser dans la pratique l'objet  VCard de l'exemple, il vous faut conna&icirc;tre les noms de propri&eacute;t&eacute;s  VCard. Ceux-ci sont document&eacute;s par l'Internet Mail Consortium. Il est important de toujours remplacer un point virgule par un tiret de soulignement. Ainsi une propri&eacute;t&eacute; VCard comme <code>TEL;CELL;VOICE</code> est not&eacute;e, lors de l'appel d'une m&eacute;thode comme <var>VCset</var>,  comme <code>TEL_CELL_VOICE</code>. Quelques unes des propri&eacute;t&eacute;s Vcard possibles contiennent &eacute;galement encore d'autres signes comme <code>=</code> et <code>-</code>. Pour traiter celles-ci correctement, vous devez sans doute encore &eacute;tendre les m&eacute;thodes <code>VCopen</code> et <code>VCsave</code> de l'objet ce &agrave; quoi il a &eacute;t&eacute; renonc&eacute; dans l'exemple pour des raisons de simplification.</p>



<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr><td colspan="2" bgcolor="#EEEEEE" class="doc">
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a>
</td></tr>
<tr><td bgcolor="#EEEEEE" class="doc" align="right"><a href="typiquecgi.htm"><img src="../../src/suivant.gif" width="10" height="10" border="0" hspace="10" alt="page suivante"></a></td>
<td bgcolor="#FFFFFF"><img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information"> <a href="typiquecgi.htm"><b>Instructions CGI typiques en Perl</b></a>
</td></tr>
<tr>
<td bgcolor="#EEEEEE" class="doc" align="right"><a href="tokens.htm"><img src="../../src/precedent.gif" width="10" height="10" border="0" hspace="10" alt="page pr&eacute;c&eacute;dente"></a></td>
<td bgcolor="#FFFFFF" width="100%"><img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information"> <a href="tokens.htm"><b>Tokens</b></a>
</td>
</tr>
<tr><td colspan="2" bgcolor="#EEEEEE" class="doc">&#160;</td></tr>
</table><table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td bgcolor="#FFEEDD" class="nav"><a class="an" name="bottom"><img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"></a> <a href="../../index.htm"><b>SELFHTML</b></a>/<a href="../../navigation/index.htm" target="_parent">Aides &agrave; la navigation</a> <img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"> <a href="../index.htm"><b>CGI/Perl</b></a> <img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"> <a href="index.htm"><b>&Eacute;l&eacute;ments de langage Perl</b></a></td>
</tr>
</table>

<p>&copy; 2001 Stefan M&uuml;nz / &copy; 2003 Traduction <img src="../../src/courriel.gif" width="15" height="10" border="0" alt="Adresse &eacute;lectronique">&nbsp;<a href="mailto:13405@free.fr">Serge Fran&ccedil;ois, 13405@free.fr</a><br><img src="../../src/courriel.gif" width="15" height="10" border="0" alt="Adresse &eacute;lectronique">&nbsp;<a href="mailto:selfhtml@selfhtml.com.fr">selfhtml@selfhtml.com.fr</a></p>



</body>
</html>
