<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>SELFHTML: CGI/Perl / Modules Perl / Introduction pour travailler avec des modules</title>
<link rel="stylesheet" type="text/css" href="../../src/selfhtml.css">
<meta name="description"    content="Quelles sont les possibilit&eacute;s d'incorporer des modules et quand l'utilisation de modules est-elle conseill&eacute;e.">
<meta name="keywords"       content="SELFHTML, Perl, modules, Modules Perl, @INC, @EXPORT, @EXPORT_OK, use, require">
<meta name="author"         content="Stefan M&uuml;nz, selfhtml@teamone.de">
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta name="DC.Publisher"   content="Serge Fran&ccedil;ois, selfhtml@selfhtml.com.fr">
<meta name="DC.Date"        content="2003-01-27T08:00+00:00">
<meta name="DC.Identifier"  content="http://selfhtml.selfhtml.com.fr/cgiperl/modules/intro.htm">
<meta name="DC.Language"    content="fr">
<meta name="DC.Rights"      content="../../editorial/copyright.htm">
<meta name="DC.Date.Create" content="2003-01-27T08:00+00:00">
<meta name="SELF.Version"   content="1">
<meta name="SELF.Pagetype"  content="Information">
<meta name="SELF.Path"      content="SELFHTML == ../../index.htm // CGI/Perl == ../index.htm // Modules Perl == index.htm">
<!-- Matomo -->
<script type="text/javascript">
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//matomo.boitasite.com/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#AA5522" vlink="#772200" alink="#000000">

<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td bgcolor="#FFEEDD" class="nav"><a class="an" name="top"><img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"></a> <a href="../../index.htm"><b>SELFHTML</b></a>/<a href="../../navigation/index.htm" target="_parent">Aides &agrave; la navigation</a> <img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"> <a href="../index.htm"><b>CGI/Perl</b></a> <img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"> <a href="index.htm"><b>Modules Perl</b></a></td>
</tr>
</table><table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td bgcolor="#EEEEEE" class="doc" width="110"><img src="../../src/logo.gif" width="106" height="109" border="0" alt="SELFHTML"></td>
<td bgcolor="#EEEEEE" class="doc" valign="bottom" width="100%"><h2>Introduction pour travailler avec des modules</h2>
<tr>
<td bgcolor="#EEEEEE" class="doc" valign="top" align="center">
<img src="../../src/docx.gif" width="30" height="20" vspace="6" border="0" alt="Page d'information: vue d'ensemble">
</td>
<td bgcolor="#FFFFFF" valign="top" nowrap>
<p>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#generalites"><b>G&eacute;n&eacute;ralit&eacute;s sur les modules en Perl</b></a><br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#require_use"><b>Incorporer des modules avec  require et use</b></a><br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#lieux_sauvegarde_inc"><b>Emplacement de sauvegarde des modules et de la liste @INC</b></a><br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#syntaxe_adressage"><b>Syntaxe d'adressage pour l'incorporation de modules</b></a><br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#packages_module"><b>Packages et modules</b></a><br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#use_etendu"><b>Utilisation &eacute;tendue de use (@EXPORT, @EXPORT_OK et qw)</b></a><br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#perldoc"><b>Lire la documentation des modules avec perldoc</b></a><br>
</p>
</td>
</tr><tr><td colspan="2" bgcolor="#EEEEEE" class="doc">&#160;<a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;</td></tr>
</table>



<h2 class="Sh2"><a class="an" name="generalites">G&eacute;n&eacute;ralit&eacute;s sur les modules en Perl</a></h2>

<p>En programmant, vous vous rendrez vite compte que vous avez toujours besoin de certaines t&acirc;ches routini&egrave;res . Les fichiers doivent toujours &ecirc;tre lus et relus, dans un environnement CGI, les formulaires doivent toujours &ecirc;tre exploit&eacute;s, Pour la communication avec d'autres ordinateurs sur Internet, il faut toujours &eacute;tablir une interface de connexion Internet etc... Maintenant, l'interpr&eacute;teur Perl Internet dispose bien d&eacute;j&agrave; d'une quantit&eacute; de  <img src="../../src/chap.gif" width="15" height="13" border="0" alt="Chapitre: vue d'ensemble">&nbsp;<a href="../fonctions/index.htm"><b>fonctions</b></a>, qui ma&icirc;trisent ce genre de t&acirc;ches routini&egrave;res. N&eacute;anmoins plus le nombre de ces fonctions int&eacute;gr&eacute;es &agrave; l'interpr&eacute;teur Perl est &eacute;lev&eacute;, plus l'interpr&eacute;teur sera volumineux, lent et gourmand en ressources. C'est pourquoi il existe un deuxi&egrave;me type de fonctions, &agrave; savoir celles qui ne sont pas int&eacute;gr&eacute;es directement dans l'interpr&eacute;teur mais qui sont disponibles sous la forme de scripts Perl. Ces scripts Perl sp&eacute;ciaux sont appel&eacute;s <b>modules</b>. Les modules disposent de fonctions (mais aussi de variables) pour certaines t&acirc;ches routini&egrave;res. Pour pouvoir utiliser ces fonctions dans vos propres scripts Perl, incorporez simplement les modules dans lesquelles se trouvent les fonctions souhait&eacute;es. Ensuite, vous pouvez acc&eacute;der aux fonctions et variables des modules.</p>

<p>Entre-temps il y a des milliers de modules Perl qui sont disponibles gratuitement. Il n'y a plus gu&egrave;re un domaine de programmation pour lequel il n'existe pas d&eacute;j&agrave; des modules avec des fonctions performantes toutes pr&ecirc;tes. Les modules sont mis &agrave; la disposition du public par des programmeurs z&eacute;l&eacute;s et comp&eacute;tents sur Internet. Quelques uns de ces modules se font concurrence, et au cours du temps, celui des modules qui est le meilleur dans la pratique s'impose. Naturellement, il existe aussi des modules qui sont utilis&eacute;s plus souvent que d'autres. Ce dernier point a conduit &agrave; distinguer aujourd'hui deux classes importantes de modules disponibles au public: Il existe les <b>modules standard</b> et les  <b>modules CPAN</b>. Les modules standard sont ceux qui sont livr&eacute;s avec l'interpr&eacute;teur Perl, et les modules CPAN  sont disponibles sur Internet pour &ecirc;tre t&eacute;l&eacute;charg&eacute;s. Les modules standard sont de ce fait naturellement beaucoup plus r&eacute;pandus. &Eacute;tant donn&eacute; qu'&agrave; chaque installation typique de l'interpr&eacute;teur Perl, ils sont aussi install&eacute;s, ils peuvent &eacute;galement &ecirc;tre utilis&eacute;s presque aussi tranquillement que les fonctions int&eacute;gr&eacute;es &agrave; Perl. Car m&ecirc;me quand un script Perl est transf&eacute;r&eacute; sur un autre ordinateur pour y faire son travail, les m&ecirc;mes modules y sont disponibles - &agrave; la condition qu'une version actuelle correspondante de l'interpr&eacute;teur Perl y soit install&eacute;e. Si par contre cous t&eacute;l&eacute;chargez des modules CPAN que vous incorporez dans vos propres scripts, le transfert d'un script sur un autre ordinateur n'est pas vraiment sans probl&egrave;mes. Car le script n'y fonctionnera qu'apr&egrave;s que les m&ecirc;mes modules CPAN y sont install&eacute;s.<br>
Dans ce chapitre, vous trouverez une partie sur les <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="modulesstandard.htm"><b>modules standard de  Perl</b></a> et une partie sur les <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="modulescpan.htm"><b>modules CPAN</b></a>. Vous y trouverez une vue d'ensemble des modules dont vous disposez.</p>

<p>Par ailleurs, il va de soi qu'il est &eacute;galement possible d'&eacute;crire ses propres modules. Pour des scripts Perl importants, il est aussi pr&eacute;f&eacute;rable de r&eacute;partir le code de telle fa&ccedil;on qu'il n'y ait plus qu'un script principal mince qui comporte des modules incorpor&eacute;s pour les diff&eacute;rentes t&acirc;ches. Supposons que vous programmiez un script Perl qui traite un fichier avec une certaine structure de donn&eacute;es. Vous pouvez tr&egrave;s bien pour ce travail &eacute;crire un module qui contienne toutes les fonctions pour lire le fichier et le copier dans des variables appropri&eacute;es et pour &eacute;crire dans le fichier les donn&eacute;es apr&egrave;s traitement. Vous pouvez ensuite simplement incorporer ce module dans le script principal et acc&eacute;der &agrave; ses fonctions et &agrave; ses variables. S'il fallait ensuite par exemple modifier le format de fichier du fichier de donn&eacute;es, seul le module doit &ecirc;tre remani&eacute; alors que le script principal et les autres modules &eacute;ventuels n'en sont pas affect&eacute;s. Vous trouverez des exemples typiques de modules propres au projet dans la partie sur la <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../langage/objets.htm"><b>programmation orient&eacute;e sur l'objet</b></a>. Ce n'est pas fortuit. Car le travail orient&eacute; sur les modules et la programmation orient&eacute;e sur l'objet, dans le style moderne, sont &eacute;troitement li&eacute;s chez Perl.</p>

<p>Les modules Perl sont donc (la plupart du temps) eux m&ecirc;mes des scripts Perl. Il s'agit toutefois de scripts pour lesquels certaines r&egrave;gles et particularit&eacute;s sont &agrave; respecter, ce qui est abord&eacute; dans le d&eacute;tail par la suite.</p>





<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="require_use"> Incorporer des modules avec require et use</a></h2>

<p>Pour l'incorporation de modules, Perl dispose des fonctions <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../fonctions/modules.htm#use"><b>use</b></a> et <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../fonctions/modules.htm#require"><b>require</b></a>. En g&eacute;n&eacute;ral, il est recommand&eacute; aujourd'hui d'utiliser la fonction <code>use</code> parce qu'elle respecte mieux l'esprit des modules. En utilisant <code>use</code> le module est incorpor&eacute; d&egrave;s le commencement du script qui l'incorpore. Il est donc &agrave; disposition avant m&ecirc;me que la premi&egrave;re ligne de code du script principal ne soit ex&eacute;cut&eacute;e. En utilisant <code>require</code> l'autre fichier par contre n'est incorpor&eacute; qu'&agrave; l'endroit ou figure l'instruction <code>require</code>. Avant l'appel correspondant, les fonctions ou variables du module ne sont donc pas disponibles et eu cas par exemple o&ugrave; l'appel de  <code>require</code> est plac&eacute; dans l'embranchement d'une instruction conditionnelle, il ne sera ex&eacute;cut&eacute; que si le script aboutit dans l'embranchement correspondant. Un exemple doit illustrer ceci.</p>

<h3 class="xmp">Exemple - partie 1: fichier module <var>moduletest.pm</var></h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

print &quot;Ici se manifeste le module \&quot;moduletest.pm\&quot;\n&quot;;

1;
</pre></td></tr></table>

<h3 class="xmp">Exemple - partie 2a: script principal <var>test_require.pl</var></h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

print &quot;Ici se manifeste le script principal\n&quot;;
require ;moduletest;
</pre></td></tr></table>

<h3 class="xmp">Exemple - partie 2b: script principal <var>test_use.pl</var></h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

print &quot;Ici se manifeste le script principal\n&quot;;
use moduletest;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>La premi&egrave;re partie de l'exemple montre le code du fichier <var>moduletest.pm</var>. Les parties de l'exemple 2a et 2b montrent chacune un script Perl dans lequel ce fichier module est incorpor&eacute;. Dans le script <var>test_require.pl</var> (2a) le module est incorpor&eacute; avec  <code>require</code>, dans le script <var>test_use.pl</var> (2b) par contre il l'est avec  <code>use</code>. Les deux scripts (2a et 2b) sont identiques mise &agrave; part la diff&eacute;rence dans l'appel de la fonction. Le r&eacute;sultat de la sortie est cependant diff&eacute;rent. Dans le 2a (donc pour l'incorporation du module avec <code>require</code> il donne:<br>
<code>Ici se manifeste le script principal<br>
Ici se manifeste le module &quot;moduletest.pm&quot;</code><br>
En 2b par contre (incorporation du module avec <code>use</code>) la sortie donne:<br>
<code>Ici se manifeste le module &quot;moduletest.pm&quot;<br>
Ici se manifeste le script principal</code><br>
La raison en est qu'un module incorpor&eacute; avec <code>use</code> est ex&eacute;cut&eacute; avant que le code du script dans lequel il est incorpor&eacute; ne soit ex&eacute;cut&eacute;. Pour <code>require</code> le script incorpor&eacute; est par contre ex&eacute;cut&eacute; &agrave; l'endroit o&ugrave; il est incorpor&eacute;.</p>

<p>&Agrave; premi&egrave;re vue, cette diff&eacute;rence plaide plut&ocirc;t pour l'emploi de <code>require</code> et moins pour celui de <code>use</code>. Dans la pratique pourtant il en est ainsi, la plupart du temps, que les fichiers modules ne contiennent pas directement de code ex&eacute;cutable mais sont constitu&eacute;s de fonctions (sous-programmes) qui peuvent ensuite &ecirc;tre appel&eacute;es dans le script qui les incorpore.</p>

<h3 class="xmp">Exemple - partie 1: fichier module <var>moduletest.pm</var></h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

sub Modulprint {
  print &quot;Ici se manifeste le module \&quot;moduletest.pm\&quot;\n&quot;;
}

1;
</pre></td></tr></table>

<h3 class="xmp">Exemple - partie 2a: script principal <var>test_require.pl</var></h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

print &quot;Ici se manifeste le script principal\n&quot;;
require moduletest;
Modulprint();
</pre></td></tr></table>

<h3 class="xmp">Exemple - partie 2b: script principal <var>test_use.pl</var></h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

print &quot;Ici se manifeste le script principal\n&quot;;
use moduletest;
Modulprint();
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>Dans cet exemple les scripts 2a et 2b g&eacute;n&egrave;rent la m&ecirc;me sortie, &agrave; savoir:<br>
<code>Ici se manifeste le script principal<br>
Ici se manifeste le module &quot;moduletest.pm&quot;</code><br>
La raison en est que le code du module figure maintenant dans un sous-programme nomm&eacute; <code>Modulprint</code>. Dans les scripts qui l'incorporent <var>test_require.pl</var> et <var>test_use.pl</var> l'instruction <code>Modulprint();</code> appelle la fonction correspondante du module incorpor&eacute;.</p>

<h3 class="inf">Attention:</h3>

<p>Une autre diff&eacute;rence importante entre <code>use</code> et <code>require</code> est que vous pouvez mentionner exactement avec <code>use</code> quels noms de fonctions et de variables exactement, vous voulez importer d'un module alors que <code>require</code> n'offre pas cette possibilit&eacute;. De plus amples renseignements '&agrave; ce sujet plus bas dans la partie <img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#use_etendu"><b> Utilisation &eacute;tendue de use (@EXPORT, @EXPORT_OK et qw)</b></a>.</p>



<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="lieux_sauvegarde_inc"> Emplacement de sauvegarde des modules et de la liste @INC</a></h2>

<p>Les fichiers modules peuvent &ecirc;tre sauvegard&eacute;s dans un des r&eacute;pertoires d&eacute;finis dans la  <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../langage/predefini.htm"><b>variable pr&eacute;d&eacute;finie</b></a> <code>@INC</code> ou dans un sous-r&eacute;pertoire de ceux-ci. Lors d'une installation typique de Perl, la liste <code>@INC</code> contient une s&eacute;rie de sous-r&eacute;pertoires du r&eacute;pertoire d'installation de Perl  ainsi que le r&eacute;pertoire actuel, &agrave; savoir la plupart du temps le r&eacute;pertoire dans lequel le script principal incorporant le fichier module se trouve.</p>

<p>La sauvegarde de fichiers modules dans le r&eacute;pertoire ou dans un sous-r&eacute;pertoire du script principal est indiqu&eacute;e quand les fichiers modules ne sont utilis&eacute;s par aucun autre script. Quand les fichiers modules contiennent du code &eacute;crit de fa&ccedil;on suffisamment g&eacute;n&eacute;rale pour que vous puissiez les utiliser pour diff&eacute;rents scripts, il est alors pr&eacute;f&eacute;rable de sauvegarder les fichiers modules dans un des autres r&eacute;pertoires nomm&eacute;s dans <code>@INC</code>.</p>

<p>Pour d&eacute;cider o&ugrave; vous pouvez sauvegarder vos fichiers modules, il vous faut d'abord conna&icirc;tre la liste des r&eacute;pertoires autoris&eacute;s. Le script Perl tout simple suivant peut vous y aider.</p>

<h3 class="xmp">Script d'exemple pour la sortie de @INC (en tant que script CGI):</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;R�pertoires de modules permis&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;\n&quot;;
print &quot;&lt;h1&gt;R�pertoires pour la sauvegarde de fichiers modules:&lt;/h1&gt;\n&quot;;
foreach (@INC) {
 print &quot;&lt;tt&gt;$_&lt;/tt&gt;&lt;br&gt;\n&quot;;
}
print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>Le script sort simplement le contenu de la liste <code>@INC</code> ligne par ligne en code HTML. Si vous sauvegardez ce code comme fichier pl dans le r&eacute;pertoire CGI et l'appelez dans le navigateur, tous les chemins de r&eacute;pertoires disponibles sont affich&eacute;s. Dans la configuration habituelle, le dernier &eacute;l&eacute;ment de la liste est un point seul (<code>.</code>). Il figure pour  &quot;r&eacute;pertoire actuel&quot; et obtient que l'interpr&eacute;teur Perl, apr&egrave;s avoir recherch&eacute; en vain un fichier incorpor&eacute; dans les chemins de r&eacute;pertoires g&eacute;n&eacute;raux, recherche dans le r&eacute;pertoire actuel.</p>

<p>Au cas o&ugrave; vous ne vouliez sauvegarder votre fichier module dans aucun des r&eacute;pertoires propos&eacute;s par <code>@INC</code>, vous pouvez aussi le sauvegarder ailleurs. Vous devez alors il est vrai, avant d'incorporer un tel fichier module, ajouter le chemin du r&eacute;pertoire o&ugrave; se trouve le fichier module &agrave; la liste <code>@INC</code>.</p>

<h3 class="xmp">Exemple:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use lib &quot;/httpd/docs/cgi-shared/special&quot;;
use lib &quot;/httpd/docs/cgi-shared/module&quot;;

print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;R�pertoires de modules permis&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;\n&quot;;
print &quot;&lt;h1&gt;R�pertoires pour la sauvegarde de fichiers modules:&lt;/h1&gt;\n&quot;;
foreach (@INC) {
 print &quot;&lt;tt&gt;$_&lt;/tt&gt;&lt;br&gt;\n&quot;;
}
print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>Par une instruction telle que <code>use lib</code> suivie de la mention d'un  chemin de r&eacute;pertoire, ce chemin est ajout&eacute; au d&eacute;but de la liste <code>@INC</code>. Le script en exemple est le m&ecirc;me script CGI que celui pour la sortie des chemins contenus dans  <code>@INC</code> qui pr&eacute;c&egrave;de. Dans le cas pr&eacute;sent, il montre que les chemins personnels ainsi d&eacute;finis ont &eacute;t&eacute; pris en consid&eacute;ration dans la liste.</p>





<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="syntaxe_adressage">Syntaxe d'adressage pour l'incorporation de modules</a></h2>

<p>Les modules peuvent &ecirc;tre sauvegard&eacute;s dans un des r&eacute;pertoires de <code>@INC</code> ou dans un de leurs sous-r&eacute;pertoires. De cette r&egrave;gle sont tir&eacute;es des formes possibles d'adressage d'un module lors de l'incorporation avec <code>use</code> ou <code>require</code>.</p>

<h3 class="xmp">Exemples pour des modules d'un r&eacute;pertoire @INC:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
require &quot;statistiques.pm&quot;;
require statistiques;
use &quot;statistiques.pm&quot;;
use statistiques;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>Les quatre exemples montrent l'incorporation d'un module sauvegard&eacute; dans un fichier nomm&eacute; <code>statistiques.pm</code>. Le fichier se trouve directement dans un des r&eacute;pertoires disponibles dans la liste <code>@INC</code> comme <img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#lieux_sauvegarde_inc"><b> Emplacement de sauvegarde des modules et de la liste @INC</b></a> possible. Les m&ecirc;mes r&egrave;gles s'appliquent pour <code>require</code> et <code>use</code>. Soit vous notez le nom de fichier complet du fichier module entre guillemets (les fichiers modules doivent avoir l'extension <code>.pm</code>), soit vous notez le nom de fichier sans l'extension <code>.pm</code> et sans guillemets.</p>

<p>Quand le fichier se trouve dans un sous-r&eacute;pertoire de l'un des r&eacute;pertoires de <code>@INC</code>, la mention de chemin relative est indispensable.</p>

<h3 class="xmp">Exemples pour des modules dans des sous-r&eacute;pertoires d'un r&eacute;pertoire de @INC:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
require &quot;modules_calcul/statistiques.pm&quot;;
require modules_calcul::statistiques;
use &quot;modules_calcul/statistiques.pm&quot;;
use modules_calcul::statistiques;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>Les quatre exemples montrent &agrave; nouveau l'incorporation d'un module  <code>statistiques.pm</code>. Le fichier se trouve dans un sous-r&eacute;pertoire nomm&eacute; <code>modules_calcul</code> de l'un des r&eacute;pertoires de <code>@INC</code>. Dans ce cas il est vrai, la syntaxe sans guillemets est &agrave; privil&eacute;gier. Car lorsque vous travaillez avec des guillemets, il vous faut adresser le fichier &agrave; incorporer avec le nom &quot;complet&quot;. La syntaxe sans guillemets se satisfait par contre du nom sans extension <var>.pm</var>. Le fichier module incorpor&eacute; doit avoir cette extension. La cha&icirc;ne de caract&egrave;res qui symbolise les s&eacute;parateurs de r&eacute;pertoires, donc les hi&eacute;rarchies est constitu&eacute;e par deux fois deux points (<code>::</code>).</p>







<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="packages_module">Packages et modules</a></h2>

<p>Quelque soit la simplicit&eacute; apparente du concept des modules en Perl - il pr&eacute;sente cependant quelques probl&egrave;mes. Supposons que vous d&eacute;finissiez dans votre propre Script Perl un sous-programme nomm&eacute; <code>get_data()</code>. Dans le m&ecirc;me script, vous incorporez un module dont le code contient &eacute;galement la d&eacute;finition d'un sous-programme nomm&eacute; <code>get_data()</code>. Afin que l'interpr&eacute;teur Perl sache &agrave; l'appel de <code>get_data()</code>, laquelle des deux fonctions est concern&eacute;e, il doit  avoir une possibilit&eacute; de lui faire savoir quelle fonction est appel&eacute;e.</p>

<p>&Agrave; cette fin il existe en Perl le concept des <b>espaces de nommage</b>. Chaque espace de nommage repr&eacute;sente ce qu'on appelle un  <b>Package</b> (<i>anglais pour paquet</i>). Chaque script Perl dans lequel vous ne faites aucune mention particuli&egrave;re de l'espace de nommage (du package) concern&eacute;, utilise un <b>package par d&eacute;faut</b>. il porte le nom <code>main</code>.</p>

<h3 class="xmp">Exemple:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

$texte_sorti = &quot;Hello ancien monde. &quot;;
print $texte_sorti;

package nouveau_monde;
$texte_sorti = &quot;Hello nouveau monde. &quot;;
print $texte_sorti;

package main;
print $texte_sorti;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple illustre l'espace de nommage par d&eacute;faut nomm&eacute; <code>main</code>. Tout d'abord une <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../langage/scalaires.htm"><b>scalaire</b></a> nomm&eacute;e <code>$texte_sorti</code> est d&eacute;finie et se voit affecter une valeur. Cette valeur est sortie tout de suite apr&egrave;s. &Eacute;tant donn&eacute; qu'&agrave; cet instant pr&eacute;cis de l'ex&eacute;cution de script, aucune autre mention concernant l'espace de nommage n'a &eacute;t&eacute; faite, le script se trouve toujours dans l'espace de nommage par d&eacute;faut <code>main</code>. Dans la deuxi&egrave;me &eacute;tape, un nouvel espace de nommage en propre nomm&eacute; <code>nouveau_monde</code> est d&eacute;fini &agrave; l'aide de la fonction <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../fonctions/modules.htm#package"><b>package</b></a>. Dans celui-ci une scalaire nomm&eacute;e <code>$texte_sorti</code> est &agrave; nouveau d&eacute;finie cette fois-ci avec une autre valeur. Cette nouvelle valeur est elle aussi sortie.</p>

<p>&Agrave; cet instant pr&eacute;cis de l'ex&eacute;cution de script deux scalaires nomm&eacute;es <code>$texte_sorti</code> existent - &agrave; savoir celle du <code>nouveau_monde</code> et celle du package par d&eacute;faut <code>main</code>. Pour le contr&ocirc;le dans l'exemple, il est &agrave; nouveau &quot;commut&eacute;&quot; sur le package <code>main</code>. Pour ce faire, c'est &agrave; nouveau la fonction <code>package</code> qui est appel&eacute;e, mais cette fois avec le nom par d&eacute;faut <code>main</code>. Des deux scalaires de ce nom existantes, c'est maintenant celle qui a &eacute;t&eacute; d&eacute;finie en premier dans le script qui est sortie, donc celle qui fait partie de l'espace de nommage par d&eacute;faut <code>main</code>. La toute derni&egrave;re commande <code>print</code> sort donc &agrave; nouveau <code>Hello ancien monde.</code>.</p>

<p>Comme le montre l'exemple, l'espace de nommage peut donc &ecirc;tre chang&eacute; &agrave; souhait &agrave; l'int&eacute;rieur d'un script. Ce qui permet d'atteindre un tr&egrave;s haut degr&eacute; de souplesse. Les modules en Perl profitent de cette souplesse. Un module peut &agrave; vrai dire par l'application de la technique des packages h&eacute;berger par exemple plusieurs classes (d'objet) dans un fichier module ou bien &eacute;largir d'autres modules (qui sont eux aussi constitu&eacute;s de packages), m&ecirc;me si la technique, il faut l'avouer n'est pas des plus propres. Un exemple simple doit illustrer ce contexte.</p>

<h3 class="xmp">Exemple - partie 1: fichier <var>moduletest.pm</var></h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
$texte_module = &quot;Ceci est le contenu de la scalaire \$texte_module\n&quot;;

package moduletest;
$texte = &quot;Ceci est le contenu de la scalaire \$texte\n&quot;;

1;
</pre></td></tr></table>

<h3 class="xmp">Exemple - Teil 2: script principal, par exemple <var>test.pl</var></h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use moduletest;

print $texte_module;
print $moduletest::texte;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>La premi&egrave;re partie de l'exemple est le script module, la deuxi&egrave;me partie le script principal. Le script module re&ccedil;oit dans l'exemple le nom <var>moduletest.pm</var> et est incorpor&eacute; dans le script principal avec l'instruction <code>use&nbsp;moduletest;</code>.</p>

<p>Le fichier module commence par la d&eacute;finition d'une scalaire nomm&eacute;e <code>$texte_module</code>. &Eacute;tant donn&eacute; qu'auparavant aucun autre  <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../fonctions/modules.htm#package"><b>package</b></a> n'est appel&eacute;, le package actif est celui dans lequel le module est incorpor&eacute;. Tout ce qui est d&eacute;fini dans cet espace de nommage, se trouve ainsi dans l'espace de nommage <code>main</code> du script qui l'incorpore. Dans l'exemple, le script qui l'incorpore, donc le script principal sort dans son espace de nommage par d&eacute;faut <code>main</code> avec <code>print&nbsp;$texte_module;</code> simplement la variable qui a &eacute;t&eacute; d&eacute;finie dans l'espace de nommage <code>main</code> du fichier module. <code>$texte_module</code> a &eacute;t&eacute; donc d&eacute;finie directement dans l'espace de nommage par d&eacute;faut du script qui incorpore. Le package <code>main</code> a donc &eacute;t&eacute; &eacute;largi par le module.</p>

<p>Dans le script module, donc dans <var>Modul.pm</var>, un nouvel espace de nommage est cependant d&eacute;fini avec  <code>package</code> plus loin dans le d&eacute;roulement du script. Il porte le m&ecirc;me nom que le fichier module sans extension, &agrave; savoir <code>moduletest</code>. Dans le script principal qui incorpore le fichier module, il ne peut &ecirc;tre acc&eacute;d&eacute; aux variables et fonctions d&eacute;finies dans le package <code>moduletest</code>, qu'en mentionnant l'espace de nommage correspondant. L'instruction <code>print&nbsp;$moduletest::texte;</code> indique comment il est acc&eacute;d&eacute; &agrave; l'autre package. Le nom d'une variable ou d'une fonction est pr&eacute;c&eacute;d&eacute; du nom du package et de deux fois deux points (<code>::</code>). Les scalaires, listes et hashes commencent toujours par leurs signes caract&eacute;ristiques <code>$</code>, <code>@</code> et <code>%</code>. Entre celui-ci et le nom de variable figure cependant le nom de package et les deux fois deux points.</p>

<h3 class="inf">Attention:</h3>

<p>L'adressage de variables ou fonctions dans d'autres packages et modules avec <code>nom de package::nom de variable/fonction</code> n'est pas possible si les variables ou fonctions sont d&eacute;clar&eacute;es avec <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../fonctions/controle.htm#my"><b>my</b></a>. C'est pourquoi l'application de <code>my</code> est aussi recommand&eacute;e dans la pratique pour obtenir un cantonnement bien propre de variables ou fonctions au seul package ou module  o&ugrave; elle ont un r&ocirc;le &agrave; jouer.</p>




<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="use_etendu">Utilisation &eacute;tendue de use (@EXPORT, @EXPORT_OK et qw)</a></h2>

<p>&Eacute;tant donn&eacute; que les modules eux-m&ecirc;mes peuvent incorporer d'autres modules et que des modules distincts doivent repr&eacute;senter des &icirc;lots de donn&eacute;es, la technique d'&eacute;largissement de packages trouve &agrave; un moment ou &agrave; un autre ses limites. Pour permettre de fixer des interfaces &quot;publiques&quot; de modules, vous avez la possibilit&eacute; de rendre visibles des symboles distincts (donc des noms de variables ou des noms de fonction par exemple) dans les deux packages (&agrave; savoir celui qui incorpore et celui qui est incorpor&eacute;). Vous pouvez exporter les symboles du module ou les importer dans le script ou module qui les incorpore.</p>

<p>Un module peut pour cette raison vous forcer &agrave; mentionner exactement, lors de l'incorporation quelles variables et fonctions vous d&eacute;sirez importer dans l'espace de nommage du script qui incorpore. Pour ce faire, il existe ce qu'on appelle le <b>module d'exportation</b> (Exporter-Modul), un module standard de Perl. Ce module attend dans le module incorpor&eacute; deux listes nomm&eacute;es  <code>@EXPORT</code> et <code>@EXPORT_OK</code>. Un module peut incorporer le module d'exportation et remplir ces deux listes avec les noms de variables et de fonctions qui peuvent &ecirc;tre principalement export&eacute;s dans un script qui incorpore. Dans le script qui incorpore vous pouvez &agrave; nouveau mentionner quels noms exportables du module vous d&eacute;sirez importer dans l'espace de nommage de votre script.</p>

<h3 class="xmp">Exemple - partie 1: fichier module <var>moduletest.pm</var></h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
package moduletest;
require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(%CHAMPS_FORMULAIRE);
@EXPORT_OK = qw($pointeuse @donnees_log recherche_client);

# ici vient le code du module ...
# dans le code ontrouve entre autres:
# un hash nomm� %CHAMPS_FORMULAIRE
# une scalaire nomm�e $pointeuse
# une liste nomm�e @donnees_log
# une fonction nomm�e recherche_client

1;
</pre></td></tr></table>

<h3 class="xmp">Exemple - partie 2: script principal, par exemple <var>test.pl</var></h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use moduletest qw($pointeuse);

# ici vient le code du script ...
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>Le fichier module incorpore lui m&ecirc;me dans l'exemple un module, &agrave; savoir le module standard <code>Exporter</code> avec  <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../fonctions/modules.htm#require"><b>require</b></a>.  L'instruction  <code>@ISA = qw(Exporter)</code> d&eacute;finit la classe <code>Exporter</code> comme classe de base de la classe actuelle, repr&eacute;sent&eacute; par le package actuel (dans l'exemple donc <code>moduletest</code>). Ce faisant, la m&eacute;thode <code>import</code>, qui est d&eacute;finie dans le module ou plut&ocirc;t la classe <code>Exporter</code>, est transmise en h&eacute;ritage &agrave; la classe  <code>moduletest</code>. Ces explications qui peuvent para&icirc;tre un peu compliqu&eacute;es sont dict&eacute;es par l'usage du langage de la programmation orient&eacute;e sur l'objet.</p>

<p>La liste <code>@EXPORT</code> peut accepter des noms du module qui sont export&eacute;s de fa&ccedil;on standard dans l'espace de nommage d'un script qui incorpore, lorsque pour l'incorporation, aucune liste d'importation n'est mentionn&eacute;e. La liste <code>@EXPORT_OK</code> accepte par contre les noms qu'un script qui incorpore peut int&eacute;grer au maximum dans son propre espace de nommage sans devoir les int&eacute;grer.</p>

<p>Dans l'exemple ci-dessus, dans le fichier module  seul un nom est not&eacute; pour la liste <code>@EXPORT</code>, &agrave; savoir un hash nomm&eacute; <code>%CHAMPS_FORMULAIRE</code>. Cette variable est export&eacute;e dans le script qui incorpore, quand, avec l'instruction <code>use</code>, aucune liste d'importation n'est mentionn&eacute;e. Pour la liste <code>@EXPORT_OK</code> trois noms sont not&eacute;s dans l'exemple: une scalaire nomm&eacute;e <code>$pointeuse</code>, une liste nomm&eacute;e <code>@donnees_log</code> et un sous-programme nomm&eacute; <code>recherche_client</code>.<br>
Pour la notation des listes l'op&eacute;rateur <code>qw</code> est particuli&egrave;rement le bienvenu, &eacute;tant donn&eacute; qu'il permet de noter les noms de variables sans devoir sans arr&ecirc;t placer des guillemets. <code>qw($pointeuse @donnees_log recherche_client)</code> correspond somme toute &agrave; la notation <code>('$pointeuse', '@donnees_log', 'recherche_client')</code>, mais est plus lisible.<br>
Dans les parenth&egrave;ses de <code>qw</code> les noms souhait&eacute;s sont not&eacute;s s&eacute;par&eacute;s par des espaces. Les noms de variables re&ccedil;oivent alors les signes distinctifs courants pour les scalaires, les listes et les hashes.</p>

<p>Le script qui incorpore dans l'exemple incorpore le module avec <code>use moduletest</code> et doit mentionner dans la liste qui suit quels noms parmi ceux nomm&eacute;s dans  <code>@EXPORT</code> ou bien <code>EXPORT_OK</code> il d&eacute;sire importer dans son propre espace de nommage. Dans l'exemple, seule la scalaire <code>$pointeuse</code> est mentionn&eacute;e et import&eacute;e comme unique nom. Si vous omettez la mention de la liste (dans l'exemple donc que vous notiez seulement <code>use moduletest;</code>), Les noms cit&eacute;s dans <code>@EXPORT</code> seraient import&eacute;s.</p>




<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="perldoc">Lire la documentation des modules avec perldoc</a></h2>

<p>Vous devez suffisamment comprendre les modules que vous n'avez pas &eacute;crits vous m&ecirc;me mais que vous d&eacute;sirez incorporer dans vos scripts, pour &ecirc;tre en mesure d'en appeler les fonctions correctement, d'en conna&icirc;tre les variables qui a sont d&eacute;finies et de les utiliser etc... C'est pourquoi au moins tous les <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="modulesstandard.htm"><b>modules standard</b></a> importants et les <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="modulescpan.htm"><b>modules du r&eacute;pertoire CPAN</b></a> sont document&eacute;s. &Eacute;tant donn&eacute; que des fichiers lisezmoi (readme) s&eacute;par&eacute;s se perdent facilement, Perl offre la possibilit&eacute;, de noter la documentation dans le fichier avec le code source. Livr&eacute; avec Perl, il y a le programme  <var>perldoc</var>, avec lequel, vous pouvez sortir la partie documentation &agrave; l'&eacute;cran.</p>

<p>L'exemple suivant montre le code complet d'un petit module standard de Perl. Le travail du module n'est pas int&eacute;ressant &agrave; cet endroit. Il vise simplement &agrave; montrer comment la documentation est int&eacute;gr&eacute;e dans le code source.</p>

<h3 class="xmp">Exemple - die fichier module &quot;Nox.pm&quot;</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
package CPAN::Nox;

BEGIN{$CPAN::Suppress_readline=1 unless defined $CPAN::term;}

use CPAN;

$VERSION = &quot;1.00&quot;;
$CPAN::META-&gt;has_inst('MD5','no');
$CPAN::META-&gt;has_inst('LWP','no');
$CPAN::META-&gt;has_inst('Compress::Zlib','no');
@EXPORT = @CPAN::EXPORT;

*AUTOLOAD = \&amp;CPAN::AUTOLOAD;

=head1 NAME

CPAN::Nox - Wrapper around CPAN.pm without using any XS module

=head1 SYNOPSIS

Interactive mode:

  perl -MCPAN::Nox -e shell;

=head1 DESCRIPTION

This package has the same functionality as CPAN.pm, but tries to
prevent the usage of compiled extensions during it's own
execution. It's primary purpose is a rescue in case you upgraded perl
and broke binary compatibility somehow.

=head1  SEE ALSO

CPAN(3)

=cut
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple montre le code du module standard <var>Nox.pm</var>. La partie sup&eacute;rieure du fichier module contient le code ex&eacute;cutable proprement-dit du module et la partie inf&eacute;rieure du fichier module contient la documentation du module. La documentation commence avec des instructions qui d&eacute;butent sur une nouvelle ligne et dont le premier caract&egrave;re est un signe &eacute;gal (<code>=</code>). Avec  <code>=head1&nbsp;NAME</code> par exemple un titre avec le texte <code>NAME</code> est cr&eacute;&eacute;. Tout ce qui vient apr&egrave;s est interpr&eacute;t&eacute; comme documentation jusqu'&agrave; l'instruction de fin <code>=cut</code>.</p>

<p>Pour pouvoir lire s&eacute;par&eacute;ment la documentation, vous devez entrer sur la ligne d'invite de votre syst&egrave;me d'exploitation:<br>
<code>perldoc [chemin]nom_module</code><br>
Sous  Windows vous pouvez utiliser la ligne d'invite de commandes DOS ou un programme qui est en mesure de capturer les r&eacute;sultats de la sortie standard d'un programme (certains des meilleurs &eacute;diteurs de texte le peuvent par exemple). Sur les syst&egrave;mes Unix, utilisez simplement une console appropri&eacute;e. Quand vous mentionnez le chemin d'un fichier module, vous pouvez s&eacute;parer les r&eacute;pertoires par une barre oblique (<code>/</code>). Ou bien vous passez dans le r&eacute;pertoire du fichier module, auquel cas vous pouvez omettre la mention de chemin.<br>
Dans l'exemple ci-dessus du fichier module <i>Nox.pm</i> les appels suivants sont possibles:<br>
<code>perldoc CPAN::Nox</code><br>
<code>perldoc Nox.pm</code><br>
<code>perldoc Nox</code><br>
<code>perldoc -m Nox</code> (dresse la liste du code source aussi)</p>





<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr><td colspan="2" bgcolor="#EEEEEE" class="doc">
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a>
</td></tr>
<tr><td bgcolor="#EEEEEE" class="doc" align="right"><a href="modulesstandard.htm"><img src="../../src/suivant.gif" width="10" height="10" border="0" hspace="10" alt="page suivante"></a></td>
<td bgcolor="#FFFFFF"><img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information"> <a href="modulesstandard.htm"><b>Modules standard de Perl</b></a>
</td></tr>
<tr>
<td bgcolor="#EEEEEE" class="doc" align="right"><a href="../fonctions/modules.htm"><img src="../../src/precedent.gif" width="10" height="10" border="0" hspace="10" alt="page pr&eacute;c&eacute;dente"></a></td>
<td bgcolor="#FFFFFF" width="100%"><img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information"> <a href="../fonctions/modules.htm"><b>Fonctions pour les modules et progiciels (packages)</b></a>
</td>
</tr>
<tr><td colspan="2" bgcolor="#EEEEEE" class="doc">&#160;</td></tr>
</table><table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td bgcolor="#FFEEDD" class="nav"><a class="an" name="bottom"><img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"></a> <a href="../../index.htm"><b>SELFHTML</b></a>/<a href="../../navigation/index.htm" target="_parent">Aides &agrave; la navigation</a> <img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"> <a href="../index.htm"><b>CGI/Perl</b></a> <img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"> <a href="index.htm"><b>Modules Perl</b></a></td>
</tr>
</table>

<p>&copy; 2001 Stefan M&uuml;nz / &copy; 2003 Traduction <img src="../../src/courriel.gif" width="15" height="10" border="0" alt="Adresse &eacute;lectronique">&nbsp;<a href="mailto:13405@free.fr">Serge Fran&ccedil;ois, 13405@free.fr</a><br><img src="../../src/courriel.gif" width="15" height="10" border="0" alt="Adresse &eacute;lectronique">&nbsp;<a href="mailto:selfhtml@selfhtml.com.fr">selfhtml@selfhtml.com.fr</a></p>


</body>
</html>
