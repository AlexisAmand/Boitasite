<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>SELFHTML: CGI/Perl / Fonctions Perl / Fonctions pour les appels du syst&egrave;me d'exploitation</title>
<link rel="stylesheet" type="text/css" href="../../src/selfhtml.css">
<meta name="description"    content="Quelles sont les fonctions en Perl qui font appel aux commandes du syst&egrave;me d'exploitation.">
<meta name="keywords"       content="SELFHTML, Perl, fonctions, Fonctions Perl, appels du syst&egrave;me, System-Calls, alarm, exec, fork, getpgrp, getppid, getpriority, kill, pipe, setpgrp, setpriority, sleep, system, times, wait, waitpid">
<meta name="author"         content="Stefan M&uuml;nz, selfhtml@teamone.de">
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta name="DC.Publisher"   content="Serge Fran&ccedil;ois, selfhtml@selfhtml.com.fr">
<meta name="DC.Date"        content="2003-01-27T08:00+00:00">
<meta name="DC.Identifier"  content="http://selfhtml.selfhtml.com.fr/cgiperl/fonctions/appelssysteme.htm">
<meta name="DC.Language"    content="fr">
<meta name="DC.Rights"      content="../../editorial/copyright.htm">
<meta name="DC.Date.Create" content="2003-01-27T08:00+00:00">
<meta name="SELF.Version"   content="1">
<meta name="SELF.Pagetype"  content="Information">
<meta name="SELF.Path"      content="SELFHTML == ../../index.htm // CGI/Perl == ../index.htm // Fonctions Perl == index.htm">



<!-- Matomo -->
<script type="text/javascript">
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//matomo.boitasite.com/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#AA5522" vlink="#772200" alink="#000000">

<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td bgcolor="#FFEEDD" class="nav"><a class="an" name="top"><img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"></a> <a href="../../index.htm"><b>SELFHTML</b></a>/<a href="../../navigation/index.htm" target="_parent">Aides &agrave; la navigation</a> <img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"> <a href="../index.htm"><b>CGI/Perl</b></a> <img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"> <a href="index.htm"><b>Fonctions Perl</b></a></td>
</tr>
</table><table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td bgcolor="#EEEEEE" class="doc" width="110"><img src="../../src/logo.gif" width="106" height="109" border="0" alt="SELFHTML"></td>
<td bgcolor="#EEEEEE" class="doc" valign="bottom" width="100%"><h2>Fonctions pour les appels du syst&egrave;me d'exploitation</h2></td>
</tr>
<tr>
<td bgcolor="#EEEEEE" class="doc" valign="top" align="center">
<img src="../../src/docx.gif" width="30" height="20" vspace="6" border="0" alt="Page d'information: vue d'ensemble">
</td>
<td bgcolor="#FFFFFF" valign="top" nowrap>
<p>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#generalites"><b>G&eacute;n&eacute;ralit&eacute;s sur ces fonctions</b></a><br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#qx"><b>qx(...)</b></a>qx(...) - ex&eacute;cuter d'autres programmes ou scripts et capturer STDOUT<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#alarm"><b>alarm</b></a> - remettre SIGALARM dans n secondes<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#exec"><b>exec</b></a> - appeler un autre programme et mettre fin au processus proprement dit<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#fork"><b>fork</b></a> - cr&eacute;er un processus enfant<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#getpgrp"><b>getpgrp</b></a> - rechercher le groupe de processus d'un num&eacute;ro de processus (pid)<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#getppid"><b>getppid</b></a> - rechercher le num&eacute;ro de processus du processus parent<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#getpriority"><b>getpriority</b></a> - rechercher la priorit&eacute; d'un processus ou d'un utilisateur<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#kill"><b>kill</b></a> - envoyer un signal au processus<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#pipe"><b>pipe</b></a> - cr&eacute;er un canal de communication (Pipe)<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#setpgrp"><b>setpgrp</b></a> - d&eacute;terminer un groupe de processus pour un processus<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#setpriority"><b>setpriority</b></a> - fixer la priorit&eacute; d'un processus ou d'un utilisateur<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#sleep"><b>sleep</b></a> - met sur pause le processus actuel<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#system"><b>system</b></a> - appeler un autre programme et recevoir son propre processus<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#times"><b>times</b></a> - rechercher la dur&eacute;e d'activit&eacute; du processus actuel<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#wait"><b>wait</b></a> - attendre la fin d'un processus enfant<br>
<img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#waitpid"><b>waitpid</b></a> - attendre la fin d'un processus enfant avec un num&eacute;ro de processus d&eacute;termin&eacute; (pid)<br>
</p>
</td>
</tr><tr><td colspan="2" bgcolor="#EEEEEE" class="doc">&#160;<a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;</td></tr>
</table>





<h2 class="Sh2"><a class="an" name="generalites">G&eacute;n&eacute;ralit&eacute;s sur ces fonctions</a></h2>


<p>Sous les &quot;appels du syst&egrave;me d'exploitation&quot; sont rassembl&eacute;es ici des fonctions qui s'orientent avant tout de tr&egrave;s pr&egrave;s au concept du syst&egrave;me d'exploitation Unix. Quelques unes de ces fonctions seulement peuvent servir sur d'autres plates-formes.</p>

<p>Les syst&egrave;mes Unix g&egrave;rent les &quot;programmes&quot; en activit&eacute; dans ce qu'on appelle des processus. Chaque processus a un num&eacute;ro de processus (PID). Par ailleurs, il y a des groupes de processus. Chaque processus fait partie d'un groupe de processus. Les groupes de processus ont &eacute;galement des num&eacute;ros. M&ecirc;me votre script Perl repr&eacute;sente, lorsqu'il est ex&eacute;cut&eacute;, un tel processus qui fait partie d'un groupe de processus. Pour beaucoup des fonctions d&eacute;crites ici, vous pouvez adresser le processus actuel, donc celui de votre script Perl par le num&eacute;ro de processus &quot;virtuel&quot; <code>0</code>. Vous pouvez cependant aussi trouver et utiliser le num&eacute;ro de processus effectif par les <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../langage/predefini.htm"><b>variables pr&eacute;d&eacute;finies</b></a>. Le script suivant expose la mise en &#339;uvre des variables correspondantes:</p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>

<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;\n&quot;;
print &quot;num�ro de processus (PID): &lt;b&gt;$$&lt;/b&gt;&lt;br&gt;\n&quot;;
print &quot;groupe d'utilisateurs r�el (GID) du processus: &lt;b&gt;$(&lt;/b&gt;&lt;br&gt;\n&quot;;
print &quot;groupe d'utilisateurs effectif (GID) du processus: &lt;b&gt;$)&lt;/b&gt;\n&quot;;
print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>Avec <code>$$</code> vous adressez le num&eacute;ro du processus actuel. Le processus tourne sous un certain num&eacute;ro d'utilisateur qui fait lui-m&ecirc;me partie de un ou plusieurs groupes. Si par exemple le script a &eacute;t&eacute; lanc&eacute; avec <code>setgid</code>, le group-ID r&eacute;el contient le(s) groupe(s) &agrave; partir duquel il a &eacute;t&eacute; lanc&eacute;, le group-ID effectif contient le(s) groupe(s) dans lequel on est pass&eacute; (le groupe actuel donc). Le script CGI en exemple sort les donn&eacute;es correspondantes.</p>

<p>D'autres concepts importants des syst&egrave;mes d'exploitation Unix auxquels vous avez acc&egrave;s avec les fonctions Perl sont les alarmes, les processus enfants et ce qu'on appelle les canaux de communication (Pipes). Vous trouverez de plus amples informations &agrave; ce sujet dans la documentation sp&eacute;cialis&eacute;e Unix.</p>



<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="qx">qx(...) - ex&eacute;cuter d'autres programmes ou scripts et capturer STDOUT</a></h2>

<p>Il ne s'agit pas ici &agrave; proprement parler d'une fonction Perl, mais d'une forme particuli&egrave;re de <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../langage/chainescaracteres.htm#regles"><b>r&egrave;gle pour la notation de cha&icirc;nes de caract&egrave;res</b></a>. <code>qx</code> figure pour <i>quoted executable</i>. La cha&icirc;ne de caract&egrave;res qui s'y trouve est simplement transform&eacute;e par Perl en un appel de la ligne de commande. La sortie standard de la commande appel&eacute;e, du programme &eacute;tranger ou du script est captur&eacute;e et peut &ecirc;tre sauvegard&eacute;e dans une variable. Une autre possibilit&eacute; de noter cette sorte de cha&icirc;ne de caract&egrave;res ex&eacute;cutable, sont ce qu'on appelle les  <i>Backticks</i>. L&agrave; vous travaillez au lieu de <code>qx(commande quelconque)</code> avec l'accent grave <code>`</code> en notant une  <code>`commande quelconque`</code>.</p>

<p>La fonctionnalit&eacute; de la cha&icirc;ne de caract&egrave;res ex&eacute;cutable est extr&ecirc;mement utile aux les scripts CGI pour leur permettre d'envoyer les sorties d'autres processus au navigateur. Ainsi par exemple des donn&eacute;es <img src="../../src/chap.gif" width="15" height="13" border="0" alt="Chapitre: vue d'ensemble">&nbsp;<a href="../../xml/index.htm"><b>XML</b></a> peuvent &ecirc;tre transcrites en HTML au moyen de <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../../xml/representation/basesxsl.htm"><b>XSLT</b></a> et d'un processeur XSLT. Quand ce processeur &eacute;crit ses r&eacute;sultats sur le <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="entreesortie.htm#generalites"><b>canal de sortie standard</b></a> <code>STDOUT</code>, le script CGI peut capturer la sortie et l'envoyer au navigateur. C'est ce que montre l'exemple suivant.</p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
my $sortie = qx(/usr/bin/saxon /donnees/xml/clients.xml /donnees/xml/clients.xsl);
print &quot;$sortie&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>Il ne faut pas plus que ce script minuscule pour envoyer des donn&eacute;es XML sous forme de donn&eacute;es HTML &agrave; un navigateur Web appelant, dans la mesure ou un processeur XSLT assure le travail de transcription. L'exemple ex&eacute;cute la commande suivante:<br>
<code>/usr/bin/saxon /donnees/xml/clients.xml /donnees/xml/clients.xsl</code><br>
Ici <code>saxon</code> est le nom d'un processeur XSLT, donc d'un programme ex&eacute;cutable. Ce programme attend normalement deux param&egrave;tres d'appel: en premier la mention d'un fichier XML, et en deuxi&egrave;me la mention d'un fichier XSL qui lui convienne avec les instructions XSLT. Saxon transcrit les marquages XML sur la base des mentions X en constructions HTML et sort le r&eacute;sultat, un fichier HTML complet sur la sortie standard. Le script capture cette sortie standard en la sauvegardant dans la variable <code>$sortie</code>. Dans cette variable se trouve le contenu complet des donn&eacute;es HTML r&eacute;sultant de l'appel de Saxon. Une simple commande print suffit ensuite pour envoyer la totalit&eacute; des donn&eacute;es HTML au navigateur appelant.</p>

<h3 class="inf">Attention:</h3>

<p>Peu importe la fa&ccedil;on de mettre entre parenth&egrave;ses lors de l'utilisation de <code>qx</code>  - Vous pouvez aussi utiliser des crochets, des parenth&egrave;ses accolades ou des barres obliques - ces derni&egrave;res &eacute;tant cependant &agrave; d&eacute;conseiller, parce que beaucoup de commandes n&eacute;cessitent des mentions de chemin et qu'il vous faudrait alors dans ce cas masquer toutes les barres obliques dans les mentions de chemin.</p>

<p>Dans les mentions de chemin utilisez aussi toujours pour <code>qx(...)</code> les barres obliques simples - m&ecirc;me si le script Perl est ex&eacute;cut&eacute; sous Windows/DOS.</p>

<p>Avec des Backticks l'appel de l'exemple ci dessus donnerait:<br>
<code>my $sortie = `/usr/bin/saxon /donnees/xml/clients.xml /donnees/xml/clients.xsl`;</code><br>
Pour cr&eacute;er des backticks appuyez sur la touche correspondant &agrave; l'accent grave, puis sur la barre d'espace.</p>

<p>Dans l'offre en ligne de SELFHTML actuel vous trouverez des liens &agrave; <img src="../../src/serverdoc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="http://www.selfhtml.com.fr/liens/logiciels_xml.htm"><b>Index des liens: logiciels XML</b></a>. Vous y trouverez aussi des liens &agrave; des produits comme Saxon.</p>

<p>La possibilit&eacute; d&eacute;crite ici est applicable &agrave; toutes les commandes qui &eacute;crivent quelque chose sur la sortie standard <code>STDOUT</code>, donc par exemple &eacute;galement aux commandes du syst&egrave;me d'exploitation comme <code>ls</code> (ou <code>dir</code>), ou m&ecirc;me &agrave; d'autres scripts Perl. Certains de ces programmes ou commandes &eacute;crivent cependant leur sortie en cas d'erreur lors de l'appel, non pas sur <code>STDOUT</code>, mais sur <code>STDERR</code>. Ces sorties <b>ne</b> sont <b>pas</b> captur&eacute;es par les cha&icirc;nes de caract&egrave;res ex&eacute;cutables d&eacute;crites ici.</p>



<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="alarm">alarm - remettre SIGALARM dans n secondes</a></h2>

<p>Commande sp&eacute;cifique &agrave; Unix. fait en sorte que le processus re&ccedil;oive un  SIGALARM apr&egrave;s un nombre de secondes d&eacute;termin&eacute; par exemple lorsqu'une commande critique ne fonctionne pas.</p>

<p>Attend comme param&egrave;tre:<br>
<b>1.</b> le nombre de secondes apr&egrave;s lesquelles l'alarme est active. </p>

<p>Renvoie le nombre de secondes qui sont &eacute;coul&eacute;es.</p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use CGI::Carp qw(fatalsToBrowser);

print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;\n&quot;;

eval {
  local $SIG{ALRM} = sub { die &quot;Alarm&quot; };
  alarm(2);
  system(&quot;/usr/bin/perl -c /usr/web/myhome/cgi-bin/freelink.pl&quot;);
  alarm(0);
};
if ($@ and $@ !~ /Alarm/) {
  print &quot;Probl�me! 2 secondes sont �coul�es!\n&quot;;
}
else {
  print &quot;Tout est en ordre!\n&quot;;
}
print &quot;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple montre comment vous pouvez traiter un &quot;appel syst&egrave;me critique&quot; &agrave; l'aide d'une alarme en compte &agrave; rebours. Pour ce faire est tout d'abord not&eacute; dans le script un bloc  <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="controle.htm#eval"><b>eval</b></a> typique pour ce genre de traitement. Y est d&eacute;fini un sous-programme de traitement pour SIGALARM avec l'instruction typique:<br>
<code>local $SIG{ALRM} = sub { die &quot;Alarm&quot; };</code><br>. Ensuite, un compte &agrave; rebours de 2 secondes est d&eacute;fini avec <code>alarm(2)</code>, avant que l'alarme soit active. Avec  <code>alarm(0)</code> l'alarme est &agrave; nouveau initialis&eacute;e.<br>
Il est ensuite tent&eacute; avec <img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#system"><b>system</b></a> d'appeler l'interpr&eacute;teur Perl, &agrave; savoir de telle fa&ccedil;on qu'il v&eacute;rifie la syntaxe d'un script d&eacute;termin&eacute;. Si cette op&eacute;ration devait durer plus de 2 secondes, l'alarme est active.<br>
Avec la requ&ecirc;te <code>if ($@ and $@ !~ /Alarm/)</code> il est v&eacute;rifi&eacute; si l'alarme a &eacute;t&eacute; active. Si oui, un message correspondant est sorti. Dans l'embranchement <code>else</code> peut figurer du code qui est ex&eacute;cut&eacute; quand tout &eacute;tait en ordre. Dan l'exemple est simplement sorti un message correspondant.</p>

<h3 class="inf">Attention</h3>

<p>Des appels avec <img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#system"><b>system</b></a> ou <img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#qx"><b>qx(...)</b></a> en relation avec <code>alarm</code> peuvent mener &agrave; ce qu'on appelle des zombies. Il est possible que, pour faire ce genre de choses , vous dussiez impl&eacute;menter vous m&ecirc;me ces appels &agrave; l'aide de <img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#fork"><b>fork</b></a> et <img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#exec"><b>exec</b></a>.</p>




<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="exec">exec - appeler un autre programme et mettre fin au processus proprement-dit</a></h2>

<p>Lance un autre processus et met fin au script actuel. Le processus actuel est ici remplac&eacute; enti&egrave;rement par un nouveau processus. Quand vous ne vous voulez pas mettre fin au script actuel, Utilisez <img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#system"><b>system</b></a>, <img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#qx"><b>qx(...)</b></a> ou bien <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="entreesortie.htm#open"><b>open</b></a> avec l'op&eacute;rateur de d&eacute;rivation de donn&eacute;es <code>|</code>.</p>


<p>Attend comme param&egrave;tre:<br>
<b>1.</b> appel de la commande du programme d&eacute;sir&eacute;,<br>
<b>2.</b> jusqu'&agrave; <b>n.</b> (facultatif) liste de param&egrave;tres d'appel.</p>

<h3 class="xmp">Exemple:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

exec(&quot;/usr/bin/perl&quot;,&quot;mystats.pl&quot;) if -e &quot;mystats.pl&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple demande &agrave; l'aide d'un  <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="gestionfichiers.htm#test_fichier"><b>op&eacute;rateur de test fichier pour fichiers et r&eacute;pertoires</b></a> <code>-e</code> si un fichier du nom de <code>mystats.pl</code> existe dans le r&eacute;pertoire actuel. Si oui, l'interpr&eacute;teur Perl est lanc&eacute; (dans un nouveau processus distinct) et ex&eacute;cute <code>mystats.pl</code>.</p>







<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="fork">fork - cr&eacute;er un processus enfant</a></h2>

<p>Commande sp&eacute;cifique &agrave; Unix. Cr&eacute;e une copie du processus actuel qui est subordonn&eacute;e au processus actuel g&eacute;niteur. Un script Perl peut ainsi traiter des donn&eacute;es dans deux processus diff&eacute;rents. Les deux processus peuvent ici acc&eacute;der &agrave; tous les fichiers ouverts. Tout le reste comme les variables etc... est copi&eacute; par le processus parent dans le processus enfant. La variable qui sauvegarde la valeur renvoy&eacute;e par <code>fork</code> a cependant une valeur dans le processus parent, &agrave; savoir le num&eacute;ro de processus du processus enfant, tandis qu'elle a dans le processus enfant la valeur <code>0</code>.</p>

<p>N'attend aucun param&egrave;tre.</p>

<p>Renvoie le num&eacute;ro de processus affect&eacute; par le syst&egrave;me d'exploitation au processus enfant.</p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

$| = 1;
print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;\n&quot;;
my $pid_parent = $$;
my $pid_enfant = fork();

if($pid_enfant) {
  print &quot;&lt;p&gt;Ceci est le processus parent. le processus enfant a le PID &lt;b&gt;$pid_enfant&lt;/b&gt;&lt;/p&gt;\n&quot;;
  wait;
}
else {
  my $pid_parent = getppid();
  print &quot;&lt;p&gt;Ceci est le processus enfant. le processus parent a le PID &lt;b&gt;$pid_parent&lt;/b&gt;&lt;/p&gt;\n&quot;;
  exit(0);
}
print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple cr&eacute;e avec <code>fork</code> un processus enfant. La valeur renvoy&eacute;e, le num&eacute;ro du processus enfant, est sauvegard&eacute;e dans la scalaire <code>$pid_enfant</code>. Dans l'exemple est ensuite not&eacute;e une requ&ecirc;te <code>if</code>. Avec <code>if($pid_enfant)</code> il est demand&eacute; si la scalaire <code>$pid_enfant</code> a une valeur diff&eacute;rente de  <code>0</code>. Si c'est le cas, des instructions relevant du processus parent sont ex&eacute;cut&eacute;es. Dans l'exemple, un message est sorti pour annoncer que le script se trouve dans le processus parent. Par ailleurs, le num&eacute;ro de processus du processus enfant est sorti. Ensuite, l'instruction <img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#wait"><b>wait</b></a> permet d'attendre que le processus enfant soit termin&eacute;. Dans l'embranchement <code>else</code> dans lequel le script aboutit quand <code>pid_enfant</code> a pour valeur  <code>0</code>, il est sorti par contre que le processus enfant est actif. Par ailleurs, le num&eacute;ro de processus du processus parent est sorti. Ensuite, le processus enfant est termin&eacute; avec l'instruction <code>exit(0);</code>. Le processus parent qui n'attendait que &ccedil;a, sort encore la derni&egrave;re ligne de code HTML.<br>
La conduite particuli&egrave;re du script qui tourne dans deux processus est mise en &eacute;vidence dans l'exemple en ce que <b>tant</b> l'embranchement <code>if</code>  <b>que</b> l'embranchement <code>else</code> sont ex&eacute;cut&eacute;s. L'explication en est que la condition  <code>if</code> est vraie pour le processus parent, et que l'alternative <code>else</code> l'est par contre pour le processus enfant.</p>







<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="getpgrp">getpgrp - rechercher le groupe de processus d'un num&eacute;ro de processus (pid)</a></h2>

<p>Commande sp&eacute;cifique &agrave; Unix.</p>

<p>Attend comme param&egrave;tre:<br>
<b>1.</b> un num&eacute;ro de processus dont le groupe de processus correspondant doit &ecirc;tre recherch&eacute;. Pour rechercher le num&eacute;ro de groupe du processus actuel, transmettre <code>0</code>.</p>

<p>Renvoie le num&eacute;ro de groupe.</p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;\n&quot;;

my $numero_groupe = getpgrp(0);
print &quot;Le num�ro du groupe de processus du processus actuel est &lt;b&gt;$numero_groupe&lt;/b&gt;\n&quot;;

print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple recherche le num&eacute;ro de groupe du processus actuel avec <code>getpgrp</code>, envoie du code HTML au navigateur et sort le num&eacute;ro trouv&eacute;.</p>







<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="getppid">getppid - rechercher le num&eacute;ro de processus du processus parent</a></h2>

<p>Commande sp&eacute;cifique &agrave; Unix.</p>

<p>N'attend aucun param&egrave;tre.</p>

<p>Renvoie le num&eacute;ro de processus du processus parent du script actuel.</p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;\n&quot;;

my $pid_parent = getppid();
print &quot;Le PID du processus parent est &lt;b&gt;$pid_parent&lt;/b&gt;\n&quot;;

print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple recherche le PID du processus parent avec <code>getppid</code>, envoie du code HTML au navigateur et sort le num&eacute;ro trouv&eacute;.</p>







<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="getpriority">getpriority - rechercher la priorit&eacute; d'un processus ou d'un utilisateur</a></h2>

<p>Commande sp&eacute;cifique &agrave; Unix. Recherche la priorit&eacute; actuelle d'un processus, d'un groupe de processus ou d'un utilisateur. Les processus avec une priorit&eacute; haute re&ccedil;oivent sous le processus actuellement en cours, plus de ressources syst&egrave;me pour leur ex&eacute;cution.</p>

<p>Attend comme param&egrave;tre:<br>
<b>1.</b> une mention exprimant si vous voulez rechercher la priorit&eacute; pour un processus d&eacute;termin&eacute;, un groupe de processus ou un utilisateur. Pour ce faire transmettez pour le mieux une des constantes qui sont d&eacute;finies dans <code>resources.ph</code> (voir plus bas).<br>
<b>2.</b> le num&eacute;ro du processus, du groupe de processus ou de l'utilisateur.</p>

<p>Renvoie la priorit&eacute; du processus, du groupe de processus ou de l'utilisateur en tant que nombre. La plage de valeurs possibles d&eacute;pend du syst&egrave;me.</p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;\n&quot;;

require &quot;resource.ph&quot;;
my $Prio = getpriority(&amp;PRIO_PROCESS,0);
print &quot;Priorit� du processus actuel: $Prio\n&quot;;

print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple recherche avec <code>getpriority</code> la priorit&eacute; du processus actuel et sort celle-ci. Pour ce faire est incorpor&eacute; avec <code>require&nbsp;&quot;resource.ph&quot;</code> le fichier d'ent&ecirc;te qui contient la d&eacute;finition des constantes suivantes:</p>


<table cellpadding="0" cellspacing="0" border="0"
bgcolor="#C0C0C0"><tr><td>
<table cellpadding="3" cellspacing="1" border="0"
>
<tr>
<th bgcolor="#EEEEEE" class="doc" align="left">Constante:</th>
<th bgcolor="#EEEEEE" class="doc" align="left">Signification:</th>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>PRIO_PROCESS</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Rechercher la priorit&eacute; d'un certain processus, dont le num&eacute;ro de processus  (ou bien 0 pour le processus actuel) est mentionn&eacute; dans le deuxi&egrave;me param&egrave;tre de <code>getpriority</code>.</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>PRIO_PGRP</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Rechercher la priorit&eacute; d'un groupe de processus dont le num&eacute;ro de processus  (ou bien 0 pour le processus actuel) est mentionn&eacute; dans le deuxi&egrave;me param&egrave;tre.</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>PRIO_USER</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Rechercher la priorit&eacute; d'un utilisateur dont le num&eacute;ro d'utilisateur (UID - ou 0 pour l'utilisateur actuel) est mentionn&eacute; dans le deuxi&egrave;me param&egrave;tre.</td>
</tr>
</table>
</td></tr></table>

<p>En la faisant pr&eacute;c&eacute;der du signe <code>&amp;</code> vous pouvez transmettre l'une des constantes comme premier param&egrave;tre, comme dans l'exemple.</p>


<h3 class="inf">Attention:</h3>

<p>Cette fonction conduit &agrave; une erreur grave quand le syst&egrave;me ne conna&icirc;t pas la gestion de processus ou d'utilisateurs telle que la comprend Unix.</p>





<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="kill">kill - envoyer un signal au processus</a></h2>

<p>Commande sp&eacute;cifique &agrave; Unix. Gr&acirc;ce &agrave; cette commande, vous pouvez, &agrave; partir d'un script Perl, envoyer des signaux &agrave; d'autres processus qui tournent sur l'ordinateur et par l&agrave; m&ecirc;me, influencer ceux-ci. Ce qui est int&eacute;ressant avant tout quand vous cr&eacute;ez dans votre script Perl vos propres processus enfants (voir <img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#fork"><b>fork</b></a>). Les processus parent et enfant peuvent alors communiquer par des signaux.</p>

<p>Attend comme param&egrave;tre:<br>
<b>1.</b> Num&eacute;ro ou nom d'une constante (voir le tableau ci-dessous) du signal d&eacute;sir&eacute; (ou transmettre <code>0</code> pour trouver si le processus, dont le num&eacute;ro de processus suit dans la transmission, est encore &quot;en vie&quot;),<br>
<b>2.</b> &agrave; <b>n.</b> un ou plusieurs processus auxquels le signal doit &ecirc;tre envoy&eacute;.</p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

$| = 1;
print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;\n&quot;;

my $pid_enfant = fork();

if(kill(0,$pid_enfant)) {
  print &quot;&lt;p&gt;Ici un processus s'annonce&lt;/p&gt;\n&quot;;
  kill(&quot;KILL&quot;,$pid_enfant);
}
print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple g&eacute;n&egrave;re un processus enfant avec <img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#fork"><b>fork</b></a> . Il est demand&eacute; si ce processus est encore en vie avec <code>if(kill(0,$pid_enfant))</code>. Si oui,, une sortie signale qu'un processus s'annonce. &Eacute;tant donn&eacute; que dans l'exemple aucun code Perl distinct n'est not&eacute; pour le processus enfant et que les processus enfants copient d'abord tout de leurs processus parents, <b>les deux</b> processus s'annonceraient et sortiraient <code>Ici un processus s'annonce</code>. Dans l'exemple, cela est cependant emp&ecirc;ch&eacute; par le fait que le processus parent tue le processus enfant avec <code>kill(&quot;KILL&quot;,$pid_enfant)</code> avant que celui-ci ne puisse ex&eacute;cuter l'instruction avec la sortie du message. Le message n'est donc sorti qu'une seule fois en tout et pour tout.</p>

<p>Le tableau suivant contient les signaux typiques avec leur nom tels qu'ils peuvent &ecirc;tre transmis comme premier param&egrave;tre &agrave; <code>kill</code>. Il n'y a aucune garantie que tous les signaux dont la liste est dress&eacute; ici fonctionnent sur chaque ordinateur en Perl. M&ecirc;me les num&eacute;ros correspondants ont &eacute;t&eacute; laiss&eacute;s de c&ocirc;t&eacute; ici, &eacute;tant donn&eacute; qu'ils peuvent varier d'un syst&egrave;me &agrave; l'autre. Finalement c'est en fin de compte toujours ce qui est d&eacute;fini dans le fichier <code>/usr/include/signal.h</code> de l'ordinateur concern&eacute; qui l'emporte.</p>

<table cellpadding="0" cellspacing="0" border="0"
bgcolor="#C0C0C0"><tr><td>
<table cellpadding="3" cellspacing="1" border="0"
>
<tr>
<th bgcolor="#EEEEEE" class="doc" align="left">Nom:</th>
<th bgcolor="#EEEEEE" class="doc" align="left">Signification:</th>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;HUP&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">&Eacute;v&eacute;nement: connexion termin&eacute;e</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;INT&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">&Eacute;v&eacute;nement: interruption g&eacute;n&eacute;rale</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;QUIT&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">&Eacute;v&eacute;nement: signal de fin</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;ILL&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">L'instruction est ill&eacute;gale</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;TRAP&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">L'instruction est un &quot;pi&egrave;ge&quot;</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;ABRT&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Interruption</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;FPE&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Erreur lors du calcul avec virgule flottante</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;KILL&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">&quot;fermer&quot; le processus (Unix: kill -9)</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;BUS&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Erreur de transmission par bus</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;SEGV&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Erreur de protection d'un segment m&eacute;moire</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;PIPE&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Erreur sur le canal de communication</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;ALARM&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Alarme g&eacute;n&eacute;rale</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;TERM&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Fin</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;USR1&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">personnalis&eacute; 1</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;USR2&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">personnalis&eacute; 2</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;CHLD&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Signal du processus enfant</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;PWR&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Panne de courant</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;WINCH&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">La taille de la fen&ecirc;tre a &eacute;t&eacute; modifi&eacute;e par un processus en arri&egrave;re plan</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;URG&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Condition urgente</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;IO&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Entr&eacute;e/Sortie asynchrone</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;STOP&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Mettre en pause le processus</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;TSTP&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Mettre en pause le processus &agrave; partir du terminal</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;CONT&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Continuer le processus mis en pause</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;TTIN&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Mettre en pause le processus par la lecture du terminal de contr&ocirc;le</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;TTOU&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Mettre en pause le processus par l'&eacute;criture du terminal de contr&ocirc;le</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;VTALARM&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Synchronisateur de temps virtuel &eacute;coul&eacute;</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;PROF&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Synchronisateur de temps du profil &eacute;coul&eacute;</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;XCPU&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Limite de surcharge du CPU atteinte</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&quot;XSFZ&quot;</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Limite de taille de fichier atteinte</td>
</tr>
</table>
</td></tr></table>

<h3 class="inf">Attention:</h3>

<p>Avec le script suivant, vous pouvez questionner votre ordinateur serveur pour conna&icirc;tre quels signaux y sont configur&eacute;s sous quel num&eacute;ro de signal:</p>

<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl

use Config;

defined $Config{sig_name} || die &quot;Pas de module de configuration?&quot;;
foreach $name (split(' ', $Config{sig_name})) {
  $i++;
  printf &quot;%3d) %s \t&quot;, $i, $name;
  if (($i % 5) == 0) { print &quot;\n&quot;;  }
}
print &quot;\n&quot;;
</pre></td></tr></table>

<br>&nbsp;

<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="pipe">pipe - cr&eacute;er un canal de communication (Pipe)</a></h2>

<p>Commande sp&eacute;cifique &agrave; Unix. Permet &agrave; deux processus de communiquer entre eux. Un &quot;canal&quot; (Pipe) est ici le canal de communication pour les deux processus. Il existe un canal pour l'&eacute;criture de donn&eacute;es et un autre pour la lecture de donn&eacute;es. Il y a  un &quot;descripteur&quot; pour chacun de ces deux canaux. Ces descripteurs de lecture et d'&eacute;criture sont tout &agrave; fait semblables aux <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="entreesortie.htm#generalites"><b>descripteurs de fichiers</b></a>. Il est courant qu'un canal soit ouvert avant m&ecirc;me qu'un processus enfant soit cr&eacute;&eacute; avec <img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#fork"><b>fork</b></a>. Les processus parent et enfant peuvent ainsi &eacute;changer des donn&eacute;es par le canal ouvert.</p>

<p>Attend comme param&egrave;tre:<br>
<b>1.</b> le nom d'un descripteur de lecture (peut &ecirc;tre attribu&eacute; librement),<br>
<b>2.</b> le nom d'un descripteur d'&eacute;criture (peut &ecirc;tre attribu&eacute; librement)</p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

$| = 1;
print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;\n&quot;;

pipe(DESCRIPTEUR_LECTURE, DESCRIPTEUR_ECRITURE);
my $pid_enfant = fork();

if ($pid_enfant) {
 close(DESCRIPTEUR_LECTURE);
 my $old_handle = select(DESCRIPTEUR_ECRITURE);
 $| = 1;
 for (my $i=1;$i&lt;=5;$i++) {
   sleep(1);
   print DESCRIPTEUR_ECRITURE &quot;$i (envoy� par le processus parent)\n&quot;;
 }
 close(DESCRIPTEUR_ECRITURE);
 wait;
 select($old_handle);
}
else {
 close(DESCRIPTEUR_ECRITURE);
my $memoire;
 while(defined($memoire = &lt;DESCRIPTEUR_LECTURE&gt;)) {
   print &quot;Lu: $memoire \n&quot;;
 }
 exit(0);
}
print &quot;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple cr&eacute;e un canal avec <code>pipe</code>. Par les deux noms de descripteur transmis <code>DESCRIPTEUR_LECTURE</code> et <code>DESCRIPTEUR_ECRITURE</code> un &eacute;change de messages est ensuite possible entre deux processus. Le script g&eacute;n&egrave;re un processus enfant &agrave; l'aide de <img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#fork"><b>fork</b></a> . Le processus parent tourne dans l'embranchement <code>if</code> du code qui suit, le processus enfant dans l'embranchement <code>else</code>. Lors de la cr&eacute;ation du processus enfant, tout est copi&eacute; except&eacute;s les deux descripteurs du canal. Ceux-ci ne sont pas copi&eacute;s, restent il est vrai disponibles pour les deux processus. C'est pourquoi chacun des deux processus doit d'abord fermer le descripteur dont il n'a pas besoin avec  <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="entreesortie.htm#close"><b>close</b></a>. Pour pouvoir basculer la mise en m&eacute;moire tampon des donn&eacute;es, il faut en outre, dans l'embranchement <code>if</code> choisir le descripteur d'&eacute;criture avec <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="entreesortie.htm#select"><b>select</b></a>. Toutes les instructions que ce soit dans l'embranchement  <code>if</code> ou m&ecirc;me dans l'embranchement <code>else</code> sont ex&eacute;cut&eacute;es cinq fois en tout. Car dans une  <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../langage/boucles.htm#for"><b>boucle for</b></a>, qui compte de 1 &agrave; 5, le processus parent &eacute;crit l'&eacute;tat actuel du compteur dans le descripteur d'&eacute;criture, apr&egrave;s qu'il a attendu une seconde pour les raisons du test (voir <img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas">&nbsp;<a href="#sleep"><b>sleep</b></a>). Le processus enfant peut lire ces donn&eacute;es dans l'embranchement <code>else</code> en employant une <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../langage/boucles.htm#while"><b>boucle while</b></a> o&ugrave; il lit le descripteur de lecture. Pour le contr&ocirc;le, le processus enfant sort ce qu'il a lu.</p>







<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="setpgrp">setpgrp - d&eacute;terminer un groupe de processus pour un processus</a></h2>

<p>Commande sp&eacute;cifique &agrave; Unix. Affecte un processus &agrave; un groupe de processus.</p>

<p>Attend comme param&egrave;tre:<br>
<b>1.</b> le num&eacute;ro de processus (PID) du processus souhait&eacute;  (transmettre <code>0</code> pour le processus actuel),<br>
<b>2.</b> le num&eacute;ro du groupe de processus auquel ce processus doit &ecirc;tre affect&eacute; ((transmettre <code>0</code> pour le groupe de processus actuel).</p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;\n&quot;;
my $ancien_groupe = getpgrp(0);
print &quot;ancien groupe de processus: &lt;b&gt;$ancien_groupe&lt;/b&gt;&lt;br&gt;\n&quot;;

setpgrp(0,0);

my $nouveau_groupe = getpgrp(0);
print &quot;ancien groupe de processus: &lt;b&gt;$nouveau_groupe&lt;/b&gt;\n&quot;;

print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple affecte le processus actuel au groupe de processus actuel et g&eacute;n&egrave;re ainsi son propre groupe de processus. Pour permettre de comparer, le groupe de processus  est lu et sorti respectivement avant et apr&egrave;s.</p>






<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="setpriority">setpriority - fixer la priorit&eacute; d'un processus ou d'un utilisateur</a></h2>

<p>Commande sp&eacute;cifique &agrave; Unix. Fixe la priorit&eacute; d'un processus, d'un groupe de processus ou d'un utilisateur. Les processus avec un degr&eacute; de priorit&eacute; plus &eacute;lev&eacute; re&ccedil;oivent sous le processus actuellement en cours plus de ressources syst&egrave;me pour leur ex&eacute;cution.<br>
&Eacute;tant donn&eacute; que cette fonction est &quot;critique pour le syst&egrave;me&quot;, elle n'est disponible sur la plupart des syst&egrave;mes Unix, que pour les utilisateurs disposant d'une identification racine.</p>

<p>Param&egrave;tres comme pour <img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#getpriority"><b>getpriority</b></a></p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;\n&quot;;

require &quot;resource.ph&quot;;
my $Prio = getpriority(&amp;PRIO_PROCESS,0);
$Prio += 1;
setpriority (&amp;PRIO_PROCESS, 0, $Prio);
print &quot;Nouvelle priorit� du processus actuel: $Prio\n&quot;;

print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple lit la priorit&eacute; du processus actuel avec <code>getpriority</code>, augmente ensuite celle-ci de 1 et fixe alors la nouvelle valeur avec <code>setpriority</code>. Pour le contr&ocirc;le, le script sort la valeur actuelle de la priorit&eacute;.</p>

<h3 class="inf">Attention:</h3>

<p>Cette fonction conduit &agrave; une erreur grave quand le syst&egrave;me ne conna&icirc;t pas la gestion de processus ou d'utilisateurs telle que la comprend Unix.</p>






<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="sleep">sleep - met sur pause le processus actuel</a></h2>

<p>Arr&ecirc;te l'ex&eacute;cution du script pour un certain nombre de secondes avant de poursuivre.</p>

<p>Attend comme param&egrave;tre:<br>
<b>1.</b> le nombre de secondes que doit durer la pause. Quand rien n'est mentionn&eacute;, la pause dure &quot;&eacute;ternellement&quot;.</p>

<h3 class="xmp">Exemple:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;

sleep(10);
exec(&quot;/usr/bin/perl&quot;,&quot;reveil.pl&quot;);
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple attend 10 secondes par un appel de <code>sleep(10)</code> et ex&eacute;cute ensuite un autre script avec <img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#exec"><b>exec</b></a>.</p>







<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="system">system - appeler un autre programme et recevoir son propre processus</a></h2>

<p>Appelle un autre programme et recherche la valeur qu'il renvoie. Quand vous &ecirc;tes int&eacute;ress&eacute; par les sorties g&eacute;n&eacute;r&eacute;es par l'autre programme, vous devez utiliser la fonction <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="entreesortie.htm#open"><b>open</b></a> avec le signe <code>|</code> ou <img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#qx"><b>qx(...)</b></a> ou encore <code>`...`</code> (Backticks).</p>

<p>Attend comme param&egrave;tre:<br>
<b>1.</b> une cha&icirc;ne de caract&egrave;res ou une liste. Si plusieurs param&egrave;tres sont transmis, donc une liste, le premier param&egrave;tre est interpr&eacute;t&eacute; comme programme ou commande &agrave; ex&eacute;cuter et les autres param&egrave;tres comme param&egrave;tres transmis au programme ou &agrave; la commande.</p>

<p>Renvoie la valeur retourn&eacute;e par le programme ou la commande ex&eacute;cut&eacute;s.</p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

(my $fichier_1, my $fichier_2) = split(/&/,$ENV{'QUERY_STRING'});
my $fichier_chemin_1 = &quot;/usr/web/daten/ancien/&quot;.$fichier_1;
my $fichier_chemin_2 = &quot;/usr/web/daten/nouveau/&quot;.$fichier_2;
my $comparaison = system(&quot;cmp $fichier_chemin_1 $fichier_chemin_2 &gt;/dev/null&quot;);

print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n&quot;;
if($comparaison == 0) {
  print &quot;&lt;tt&gt;$fichier_chemin_1&lt;/tt&gt;&lt;br&gt;et&lt;br&gt;&lt;tt&gt;$fichier_chemin_2&lt;/tt&gt;&lt;br&gt;&lt;b&gt;sont identiques!&lt;/b&gt;!\n&quot;;
}
else {
  print &quot;&lt;tt&gt;$fichier_chemin_1&lt;/tt&gt;&lt;br&gt;et&lt;br&gt;&lt;tt&gt;$fichier_chemin_2&lt;/tt&gt;&lt;br&gt;&lt;b&gt;sont diff�rents!&lt;/b&gt;!\n&quot;;
}
print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>Le script en exemple recherche le contenu de la  <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../introduction/variablesenvironnement.htm"><b>variable d'environnement CGI</b></a> <code>QUERY_STRING</code>, y recherche un ET commercial (<code>&</code>) et s&eacute;pare la partie qui le pr&eacute;c&egrave;de de celle qui lui succ&egrave;de dans les scalaires <code>$fichier_1</code> et  <code>$fichier_2</code>. Les deux donn&eacute;es sont interpr&eacute;t&eacute;es comme fichiers. Un appel en exemple du script pourrait &ecirc;tre:<br>
<var>/cgi-bin/script.pl?nouveautes.htm&amp;nouveautes.htm</var><br>
Le script accroche les deux fichiers du m&ecirc;me nom &agrave; diff&eacute;rents noms de chemin sur le serveur en cr&eacute;ant ainsi deux mentions diff&eacute;rentes de chemin de fichier dans les scalaires <code>$fichier_chemin_1</code> et <code>$fichier_chemin_2</code>. Avec <code>system</code> la commande de ligne de commande <code>cmp</code> (sous Unix) est lanc&eacute;e, et v&eacute;rifie si les deux fichiers sont identiques. Les deux scalaires sont transmises &agrave; la commande avec les mentions de chemin. Si c'est le cas, la commande ne doit pas cr&eacute;er de sortie. C'est la raison pour laquelle sa sortie est d&eacute;vi&eacute;e vers <code>/dev/null</code>. La valeur renvoy&eacute;e par l'appel de <code>system</code> et par l&agrave; m&ecirc;me par la commande <code>cmp</code> est cependant sauvegard&eacute;e, &agrave; savoir dans la scalaire <code>$comparaison</code>. Quand la valeur est <code>0</code> les fichiers compar&eacute;s sont identiques, sinon ils sont diff&eacute;rents. Cette information est renvoy&eacute;e au navigateur appelant.</p>





<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="times">times - rechercher la dur&eacute;e d'activit&eacute; du processus actuel</a></h2>

<p>Recherche la dur&eacute;e d'activit&eacute; d'un processus  (et s'il y en a de ses processus enfants) depuis la cr&eacute;ation jusqu'&agrave; l'ex&eacute;cution de cet appel <code>times</code>. Deux valeurs sont recherch&eacute;es pour chaque processus: &quot;user time&quot; et &quot;system time&quot;. Alors que &quot;user time&quot; d&eacute;signe depuis combien de temps le processus lui-m&ecirc;me est en cours,  &quot;system time&quot; mentionne depuis combien de temps le processus occupe le syst&egrave;me d'exploitation. La somme des deux dur&eacute;es est la dur&eacute;e totale d'utilisation du CPU.<br>
Les temps mesur&eacute;s se basent sur le cadencement. Le cadencement par seconde est r&eacute;glable sur les syst&egrave;mes Unix (<code>TICKSPERSEC</code> dans le fichier <code>conf.h</code>).</p>

<p>N'attend aucun param&egrave;tre.</p>

<p>Renvoie une liste avec les dur&eacute;es d'ex&eacute;cution en secondes (nombres &agrave; virgules flottante, avec mention des fractions de secondes) . Sch&eacute;ma:<br>
<code>($user_time,$system_time[,$user_time_enfant,$system_time_enfant,...])</code></p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $x;
for(my $i = 0; $i &lt; 1000; $i++) {
  for(my $k = 0; $k &lt; 100; $k++) {
    $x = $i * $k / time();
  }
}

my ($duree_systeme, $duree_utilisateur) = times();
my $duree_CPU = $duree_systeme + $duree_utilisateur;

print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;\n&quot;;
print &quot;dur�e syst�me utilis�e: &lt;b&gt;$duree_systeme&lt;/b&gt; secondes&lt;br&gt;\n&quot;;
print &quot;dur�e utilisateur utilis�e: &lt;b&gt;$duree_utilisateur&lt;/b&gt; secondes&lt;br&gt;\n&quot;;
print &quot;dur�e CPU utilis�e: &lt;b&gt;$duree_CPU&lt;/b&gt; secondes\n&quot;;
print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple contient deux <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../langage/boucles.htm#for"><b>boucles for</b></a> imbriqu&eacute;es dans lesquelles beaucoup de calculs sont &agrave; faire (ce sont en tout 100.000 appels de la fonction <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="dateheure.htm#time"><b>time</b></a> et autant de calculs de nombres fractionnaires qui sont ex&eacute;cut&eacute;s). Ensuite, l'exemple recherche les nombres n&eacute;cessaires. Les deux premiers &eacute;l&eacute;ments de liste de l'appel de la fonction <code>times</code> &agrave; savoir ceux pour le processus actuel, sont sauvegard&eacute;s dans les scalaires <code>$duree_systeme</code> et <code>$duree_utilisateur</code>. &Agrave; partir de la somme de ces deux dur&eacute;es est d&eacute;duite la dur&eacute;e CPU qui est sauvegard&eacute;e dans <code>$duree_CPU</code>. Pour le contr&ocirc;le, le script sort les dur&eacute;es trouv&eacute;es.</p>






<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="wait">wait - attendre la fin d'un processus enfant</a></h2>

<p>Commande sp&eacute;cifique &agrave; Unix.</p>

<p>N'attend aucun param&egrave;tre.</p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

#use strict;
use CGI::Carp qw(fatalsToBrowser);

$| = 1;
print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;\n&quot;;
my $pid_enfant = fork();

if($pid_enfant) {
  print &quot;&lt;p&gt;Ici c'est le processus parent.&lt;/p&gt;\n&quot;;
  wait();
  print &quot;&lt;p&gt;Le processus enfant est termin�.&lt;/p&gt;\n&quot;;
}
else {
  print &quot;&lt;p&gt;Ici c'est le processus enfant.&lt;/p&gt;\n&quot;;
  exit(0);
}
print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple cr&eacute;e un processus enfant avec <img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#fork"><b>fork</b></a>. Il est demand&eacute; avec <code>if($pid_enfant)</code> si la scalaire <code>$pid_enfant</code> a une valeur diff&eacute;rente de <code>0</code>. Si c'est le cas, des instructions sont ex&eacute;cut&eacute;es qui rel&egrave;vent du processus parent. Dans l'exemple un message est sorti selon lequel le script se trouve dans le processus parent. Dans l'embranchement <code>else</code> dans lequel le script aboutit quand la valeur de <code>pid_enfant</code> &eacute;gale <code>0</code>, il est sorti que le processus enfant est actif.<br>
En principe c'est d'abord l'embranchement <code>if</code> qui est trait&eacute; puis l'embranchement <code>else</code>. Par l'instruction <code>wait()</code> de l'embranchement <code>if</code>, le processus parent attend cependant la fin du processus enfant avant de poursuivre. Ainsi, l'embranchement <code>else</code> est trait&eacute; auparavant et ensuite, le dernier message de l'embranchement <code>if</code> est sorti.</p>







<table bgcolor="#EEEEEE" class="doc" width="100%"><tr><td>
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a><a href="#bottom"><img src="../../src/bas.gif" width="14" height="10" border="0" alt="vers le bas"></a>&#160;
</td></tr></table>
<h2 class="Sh2"><a class="an" name="waitpid">waitpid - attendre la fin d'un processus enfant avec un num&eacute;ro de processus d&eacute;termin&eacute; (pid)</a></h2>

<p>Commande sp&eacute;cifique &agrave; Unix. Appelle directement le syst&egrave;me d'exploitation &agrave; la diff&eacute;rence de <img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#wait"><b>wait</b></a>.</p>

<p>Attend comme param&egrave;tre:<br>
<b>1.</b> le num&eacute;ro de processus (PID) du processus enfant souhait&eacute;.<br>
<b>2.</b> interrupteur (drapeaux - voir tableau ci-dessous)</p>

<p>Renvoie le num&eacute;ro de processus (PID) du processus arr&ecirc;t&eacute; ou <code>-1</code>, si le processus enfant souhait&eacute; n'existe pas ou n'existe plus. Sur certains syst&egrave;mes la valeur renvoy&eacute;e <code>0</code> est elle aussi possible - elle signifie que le processus enfant tourne encore toujours (c'est &agrave; dire un compte &agrave; rebours lors de l'attente a &eacute;t&eacute; d&eacute;pass&eacute;).</p>

<h3 class="xmp">Exemple d'un script CGI complet en Perl:</h3>
<table width="100%" cellpadding="10"><tr><td class="xmpcode" bgcolor="#FFFFE0"><pre>
#!/usr/bin/perl -w

#use strict;
use CGI::Carp qw(fatalsToBrowser);
use POSIX;

$| = 1;
print &quot;Content-type: text/html\n\n&quot;;
print '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;', &quot;\n&quot;;
print &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Sortie du test&lt;/title&gt;\n&quot;;
print &quot;&lt;/head&gt;&lt;body&gt;\n&quot;;
my $pid_enfant = fork();

if($pid_enfant) {
  print &quot;&lt;p&gt;Ici c'est le processus parent.&lt;/p&gt;\n&quot;;

  use POSIX &quot;:sys_wait_h&quot;;
  do {
    my $pid_enfant = waitpid(-1,&amp;WNOHANG);
  } until $pid_enfant == -1;

  print &quot;&lt;p&gt;Le processus enfant est termin�.&lt;/p&gt;\n&quot;;
}
else {
  print &quot;&lt;p&gt;Ici c'est le processus enfant.&lt;/p&gt;\n&quot;;
  exit(0);
}
print &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;;
</pre></td></tr></table>

<h3 class="xpl">Explication:</h3>

<p>L'exemple fait la m&ecirc;me chose que celui de <img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut">&nbsp;<a href="#wait"><b>wait</b></a>. Dans le cas pr&eacute;sent toutefois, il est attendu avec une  <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../langage/boucles.htm#do"><b>boucle do-until</b></a> jusqu'&agrave; ce que le processus enfant soit fini. C'est le cas quand la fonction <code>waitpid</code> retourne la valeur <code>-1</code>, le processus enfant n'existe lors donc plus.</p>


<p>&Agrave; la fonction <code>waitpid</code> le drapeau <code>&amp;WNOHANG</code> est transmis dans l'exemple. Les constantes pour le faire sont d&eacute;finies dans le <img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information">&nbsp;<a href="../modules/modulesstandard.htm"><b>module standard</b></a> <code>POSIX</code>. C'est pourquoi il est indispensable d'incorporer ce module comme dans l'exemple avec <code>use&nbsp;POSIX&nbsp;&quot;:sys_wait_h&quot;</code>.<br>
Le tableau suivant dresse la liste des drapeaux pouvant &ecirc;tre transmis &agrave; cet endroit.</p>


<table cellpadding="0" cellspacing="0" border="0"
bgcolor="#C0C0C0"><tr><td>
<table cellpadding="3" cellspacing="1" border="0"
>
<tr>
<th bgcolor="#EEEEEE" class="doc" align="left">Drapeau:</th>
<th bgcolor="#EEEEEE" class="doc" align="left">Signification:</th>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&amp;WEXITSTATUS</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Contient la valeur renvoy&eacute;e par le processus enfant (plus exactement: les 8 bits inf&eacute;rieurs, donc une valeur pouvant aller jusqu'&agrave; 255).</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&amp;WIFEXITED</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">a la valeur <code>true</code> ou <code>1</code>, quand le processus enfant a &eacute;t&eacute; quitt&eacute; normalement.</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&amp;WIFSIGNALED</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">a la valeur <code>true</code> ou <code>1</code>, quand le processus enfant a &eacute;t&eacute; termin&eacute; par un signal rest&eacute; sans r&eacute;ponse.</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&amp;WIFSTOPPED</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">a la valeur <code>true</code> ou <code>1</code>, quand le processus enfant a &eacute;t&eacute; mis en pause.</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&amp;WNOHANG</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Le processus appelant n'est pas bloqu&eacute; dans le cas o&ugrave; le processus enfant ne r&eacute;agit pas aussit&ocirc;t. En pareil cas, <code>waitpid()</code> est aussit&ocirc;t termin&eacute; en renvoyant 0.</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&amp;WSTOPSIG</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Le num&eacute;ro du signal qui a conduit &agrave; l'arr&ecirc;t momentan&eacute; du processus enfant (l'arr&ecirc;t momentan&eacute; du processus enfant peut &ecirc;tre recherch&eacute; avec <code>&amp;WIFSTOPPED</code>.</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&amp;WTERMSIG</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top">Le num&eacute;ro du signal auquel le processus enfant n'a pas r&eacute;pondu et qui a conduit &agrave; son arr&ecirc;t (on peut rechercher si c'est le cas avec <code>&amp;WIFSIGNALED</code>.</td>
</tr>
<tr>
<td class="code" bgcolor="#FFFFE0" valign="top" nowrap><code>&amp;WUNTRACED</code></td>
<td class="tabxpl" bgcolor="#E4EEFF" valign="top"><code>waitpid()</code> revient avec l'&eacute;tat d'un processus enfant d&eacute;j&agrave; arr&ecirc;t&eacute; dont la valeur renvoy&eacute;e de exit n'a pas encore &eacute;t&eacute; questionn&eacute;e.</td>
</tr>
</table>
</td></tr></table>


<br>&nbsp;


<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr><td colspan="2" bgcolor="#EEEEEE" class="doc">
&#160;<a href="#top"><img src="../../src/haut.gif" width="14" height="10" border="0" alt="vers le haut"></a>
</td></tr>
<tr><td bgcolor="#EEEEEE" class="doc" align="right"><a href="configuration.htm"><img src="../../src/suivant.gif" width="10" height="10" border="0" hspace="10" alt="page suivante"></a></td>
<td bgcolor="#FFFFFF"><img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information"> <a href="configuration.htm"><b>Fonctions pour les informations tir&eacute;es des fichiers de configuration</b></a>
</td></tr>
<tr>
<td bgcolor="#EEEEEE" class="doc" align="right"><a href="gestionfichiers.htm"><img src="../../src/precedent.gif" width="10" height="10" border="0" hspace="10" alt="page pr&eacute;c&eacute;dente"></a></td>
<td bgcolor="#FFFFFF" width="100%"><img src="../../src/doc.gif" width="15" height="10" border="0" alt="Autre page d'information"> <a href="gestionfichiers.htm"><b> Fonctions pour la gestion de fichiers et de r&eacute;pertoires</b></a>
</td>
</tr>
<tr><td colspan="2" bgcolor="#EEEEEE" class="doc">&#160;</td></tr>
</table><table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td bgcolor="#FFEEDD" class="nav"><a class="an" name="bottom"><img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"></a> <a href="../../index.htm"><b>SELFHTML</b></a>/<a href="../../navigation/index.htm" target="_parent">Aides &agrave; la navigation</a> <img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"> <a href="../index.htm"><b>CGI/Perl</b></a> <img src="../../src/refchap.gif" width="16" height="13" border="0" alt="Renvoie au chapitre d'origine"> <a href="index.htm"><b>Fonctions Perl</b></a></td>
</tr>
</table>

<p>&copy; 2001 Stefan M&uuml;nz / &copy; 2003 Traduction <img src="../../src/courriel.gif" width="15" height="10" border="0" alt="Adresse &eacute;lectronique">&nbsp;<a href="mailto:13405@free.fr">Serge Fran&ccedil;ois, 13405@free.fr</a><br><img src="../../src/courriel.gif" width="15" height="10" border="0" alt="Adresse &eacute;lectronique">&nbsp;<a href="mailto:selfhtml@selfhtml.com.fr">selfhtml@selfhtml.com.fr</a></p>



</body>
</html>
