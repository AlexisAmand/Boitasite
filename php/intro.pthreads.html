<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Introduction</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

 </head>
 <body class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="book.pthreads.html">« pthreads</a></li>
      <li style="float: right;"><a href="pthreads.setup.html">Installation/Configuration »</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="book.pthreads.html">pthreads</a></li>
    <li>Introduction</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="intro.pthreads" class="preface">
  <h1 class="title">Introduction</h1>
  <p class="para">
   pthreads est une API orientée objet qui apporte tous les outils nécessaires pour 
   le multi-threading en PHP. 
   Les applications PHP peuvent créer, lire, écrire, exécuter
   et synchroniser des Threads, des Workers, et des objets Threaded.
  </p>
  <div class="tip"><strong class="tip">Astuce</strong>
   <p class="simpara">
    Envisager d&#039;utiliser <a href="book.parallel.html" class="link">parallel</a> à la place.
   </p>
  </div>
  <div class="warning"><strong class="warning">Avertissement</strong>
   <p class="para">
    L&#039;extension pthreads ne peut pas être utilisée dans un environnement de 
    serveur Web. Le Threading en PHP est donc limité aux applications basées 
    sur CLI uniquement.
   </p>
  </div>
  <div class="warning"><strong class="warning">Avertissement</strong>
   <p class="para">
    pthreads (v3) peut être utilisé uniquement avec PHP 7.2+ à cause d&#039;un 
    mode ZTS dangereux en PHP 7.0 et 7.1.
   </p>
  </div>
  <p class="para">
   La classe <a href="class.threaded.html" class="classname">Threaded</a> constitue la base de la 
   fonctionnalité qui permet à pthreads de fonctionner. Il expose les méthodes 
   de synchronisation et quelques interfaces utiles pour le programmeur.
  </p>
  <p class="para">
   La classe <a href="class.thread.html" class="classname">Thread</a> permet de créer des threads en 
   l&#039;étendant simplement et en implémentant une méthode <code class="literal">run</code>. 
   Tous les membres peuvent être écrits et lus par n&#039;importe quel contexte avec 
   une référence au thread. Tout contexte peut également exécuter toutes les 
   méthodes publiques et protégées. Le corps de la méthode run sera exécuté 
   dans un thread séparé lorsque la méthode <span class="methodname"><a href="thread.start.html" class="methodname">Thread::start()</a></span> 
   de l&#039;implémentation est appelée à partir du contexte qui l&#039;a créé. Seul le 
   contexte qui crée un thread peut le démarrer et le rejoindre.
  </p>
  <p class="para">
   La classe <a href="class.worker.html" class="classname">Worker</a> a un état persistant et sera 
   disponible à partir de l&#039;appel à <span class="methodname"><a href="thread.start.html" class="methodname">Thread::start()</a></span> (une 
   méthode héritée) jusqu&#039;à ce que l&#039;objet soit hors de portée, ou soit 
   explicitement arreté (via <span class="methodname"><a href="worker.shutdown.html" class="methodname">Worker::shutdown()</a></span>). Tout 
   contexte avec une référence à l&#039;objet Worker peut empiler des tâches sur le 
   Worker (via <span class="methodname"><a href="worker.stack.html" class="methodname">Worker::stack()</a></span>), où ces tâches seront 
   exécutées par le Worker dans un thread séparé. La méthode 
   <code class="literal">run</code> d&#039;un objet worker est exécutée avant tout objet de la 
   pile du worker, ce qui permet aux ressources d&#039;être initialisées pour que 
   les objets à exécuter puissent les utiliser.
  </p>
  <p class="para">
   La classe <a href="class.pool.html" class="classname">Pool</a> est utilisée pour créer un groupe de 
   worker pour distribuer des objets <a href="class.threaded.html" class="classname">Threaded</a> parmi eux. 
   Il est le moyen le plus facile et le plus efficace d&#039;utiliser plusieurs 
   threads dans les applications PHP.
  </p>
  <div class="caution"><strong class="caution">Attention</strong>
   <p class="para">
    La classe <a href="class.pool.html" class="classname">Pool</a> n&#039;étend pas la classe 
   <a href="class.threaded.html" class="classname">Threaded</a>, et donc les objets basés sur pool sont 
   considérés comme des objets PHP normaux. En tant que tel, ses instances ne d
   doivent pas être partagées entre des contextes différents.
   </p>
  </div>
  <p class="para">
   La classe <a href="class.volatile.html" class="classname">Volatile</a> est nouvelle pour pthreads v3. 
   Elle est utilisée pour désigner les propriétés <a href="class.threaded.html" class="classname">Threaded</a> 
   mutable des classes <a href="class.threaded.html" class="classname">Threaded</a> (car celles-ci sont 
   désormais immuables par défaut). Elle est également utilisé pour stocker 
   des tableaux PHP dans des contextes <a href="class.threaded.html" class="classname">Threaded</a>.
  </p>
  <p class="para">
   La synchronisation est une capacité importante lors du Threading. Tous les 
   objets créés par pthreads ont été construits en synchronisation dans la 
   forme (qui sera familière aux programmeurs Java) de
   <span class="methodname"><a href="threaded.wait.html" class="methodname">Threaded::wait()</a></span> et
   <span class="methodname"><a href="threaded.notify.html" class="methodname">Threaded::notify()</a></span>. L&#039;appel de 
   <span class="methodname"><a href="threaded.wait.html" class="methodname">Threaded::wait()</a></span> sur un objet entraînera le contexte 
   à attendre qu&#039;un autre contexte appelle
   <span class="methodname"><a href="threaded.notify.html" class="methodname">Threaded::notify()</a></span> sur le même objet. Ce mécanisme 
   permet une synchronisation puissante entre les objets 
   <a href="class.threaded.html" class="classname">Threaded</a> en PHP.
  </p>
  <div class="caution"><strong class="caution">Attention</strong>
   <p class="para">
    Tout objet prévu pour être utilisé dans une partie multi-threadé de votre 
    application doit étendre <a href="class.threaded.html" class="classname">Threaded</a>.
   </p>
  </div>
  <p class="para">
   Stockage des données : En règle générale, tous les types de données pouvant être linéarisés peuvent
   être utilisés comme membre d&#039;un objet Threadé, ils peuvent être lus, et écrits depuis n&#039;importe quel
   contexte avec une référence vers l&#039;objet Threadé. Tous les types de données ne sont pas stockés
   après linéarisation ; les types simples sont stockés sous leur forme initiale. Les types complexes,
   les tableaux et les objets qui ne sont pas Threadés, sont stockés linéarisés ; ils peuvent être lus
   et écrits dans l&#039;objet Threadé depuis n&#039;importe quel contexte avec une référence.
   A l&#039;exception des objets Threadés, toute référence utilisée pour définir un membre d&#039;un objet Threadé
   est séparé de la référence dans l&#039;objet Threadé ; les mêmes données peuvent être lues directement
   depuis l&#039;objet Threadé à tout moment par n&#039;importe quel contexte avec une référence vers l&#039;objet Threadé.
  </p>
  <p class="para">
   Membres statiques : Lorsqu&#039;un nouveau contexte est créé (Thread ou Worker), 
   ils sont généralement copiés, mais les ressources et objects avec un état 
   interne sont nullifiés (pour des raisons de sécurité). Ceci permet alors à la fonction une sorte de stockage local
   au niveau du thread. Par exemple, lors du démarrage du contexte, une classe dont les membres statiques
   incluent des informations de connexion vers un serveur de base de données, seules les informations
   seront copiées, et non la connexion en tant que telle. Ceci permet au nouveau contexte d&#039;initialiser
   une connexion de la même façon que le contexte qui l&#039;a créé, stockant la connexion au même endroit
   sans pour autant affecter le contexte original.
  </p>
  <div class="caution"><strong class="caution">Attention</strong>
  <p class="para">
   Lorsque print_r, var_dump et d&#039;autres fonctions de débogage sont exécutées, elles n&#039;incluent pas
   de protection contre la récursion.
  </p>
  </div>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <p class="para">
    Ressources : Les extensions et les fonctionalités qui définissent des ressoures en PHP ne sont pas préparées
    pour ce type d&#039;environnement ; pthreads prend des dispositions en matière de ressource à partager entre
    les contextes, cependant, pour la plupart des ressources, elles devront être considérées comme dangereuses.
    Un soin et une extrème prudence devront être de mise pour partager les ressources entre les contextes.
   </p>
  </p></blockquote>
  <div class="caution"><strong class="caution">Attention</strong>
   <p class="para">
    Dans l&#039;environnement d&#039;exécution de pthreads, des restrictions et des limitations sont nécessaires afin de
    fournir un environnement stable.
   </p>
  </div>
 </div></div></div></body></html>