<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Les filtres</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

 </head>
 <body class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="mysqlnd-ms.rwsplit.html">« S&eacute;paration des lectures et &eacute;critures</a></li>
      <li style="float: right;"><a href="mysqlnd-ms.qos-consistency.html">Niveaux de service et consistence »</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="mysqlnd-ms.concepts.html">Concepts</a></li>
    <li>Les filtres</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="mysqlnd-ms.filter" class="section">
  <h2 class="title">Les filtres</h2>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <strong>Version requise</strong><br />
   <p class="para">
    Les filtres existent depuis mysqlnd_ms version 1.1.0-beta.
   </p>
  </p></blockquote>
  <p class="para">
   <a href="mysqlnd-ms.plugin-ini-json.html" class="link">Filtres</a>.
   Toutes les applications PHP utilisant un type de cluster de réplication MySQL
   ont besoin d&#039;abord d&#039;identifier un groupe de serveurs dans le cluster qui pourront
   exécuter une requête donnée avant que la requête ne soit exécutée sur un
   des candidats. En d&#039;autres termes, une liste donnée de serveurs doit être filtrée
   pour n&#039;en faire sortir qu&#039;un.
  </p>
  <p class="para">
   Le processus de filtrage peut inclure l&#039;utilisation d&#039;un ou plusieurs filtres.
   Les filtres peuvent être chaînés. Ils sont exécutés dans l&#039;ordre de leurs
   apparitions dans le fichier de configuration du plugin.
  </p>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <strong>Comparaison du chainage des filtres avec les tubes (pipes)</strong><br />
   <p class="para">
    Le concept de chaînage des filtres peut être comparé à l&#039;utilisation des tubes des utilitaires de ligne
    de commande d&#039;un shell d&#039;un système d&#039;exploitation : un flux entrant est passé
    au processus, et transféré à la sortie. Puis, la sortie est passé comme
    entrée à la prochaine commande qui est connectée à la précédente en utilisant
    un opérateur pipe.
   </p>
  </p></blockquote>
  <p class="para">
   Les filtres suivants sont disponibles
   <ul class="itemizedlist">
    <li class="listitem">
     <span class="simpara">
      Filtre de balance de charge :
      <a href="mysqlnd-ms.plugin-ini-json.html#ini.mysqlnd-ms-plugin-config-v2.filters" class="link">random</a>,
      <a href="mysqlnd-ms.plugin-ini-json.html#ini.mysqlnd-ms-plugin-config-v2.filters" class="link">roundrobin</a>.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Filtre de sélection :
      <a href="mysqlnd-ms.plugin-ini-json.html#ini.mysqlnd-ms-plugin-config-v2.filters" class="link">user</a>,
      <a href="mysqlnd-ms.plugin-ini-json.html#ini.mysqlnd-ms-plugin-config-v2.filters" class="link">user_multi</a>,
      <a href="mysqlnd-ms.plugin-ini-json.html#ini.mysqlnd-ms-plugin-config-v2.filters" class="link">quality_of_service</a>.
     </span>
    </li>
   </ul>
  </p>
  
  <p class="para">
   Le filtre <code class="literal">random</code> implémente les
   stratégies random et random once. Round robin peut être configuré via le
   filtre <code class="literal">roundrobin</code>. La définition d&#039;une fonction de rappel utilisateur
   peut être utilisée pour la sélection des serveurs avec le filtre
   <code class="literal">user</code>.Le filtre <code class="literal">quality_of_service</code> trouve des noeuds
   capables de répondre à un certain service, par exemple, &quot;lit tes écritures&quot; ou encore
   ne pas avoir plus de X secondes de retard sur le maitre.
  </p>
  <p class="para">
   Les filtres peuvent accepter des paramètres pour changer leurs comportements.
   Le filtre <code class="literal">random</code> accepte un paramètre optionnel
   <code class="literal">sticky</code>. Si définit à <strong><code>TRUE</code></strong>, le filtre modifie la balance
   de charge de random à random once. Random sélectionne un serveur aléatoirement
   à chaque fois qu&#039;une requête est exécutée. Random once sélectionne un serveur
   aléatoirement lors de la première requête et le ré-utilise pour toutes les
   autres requêtes PHP.
  </p>
  <p class="para">
   Une des plus grosses particularités des filtres est la possibilité de
   les chaîner. La puissance de ce concept n&#039;est pas immédiatement
   visible car les filtres <code class="literal">random</code>, <code class="literal">roundrobin</code>
   et <code class="literal">user</code> ne sont supposés sortir pas plus d&#039;un serveur. Si un
   filtre réduit la liste des candidats pour l&#039;exécution d&#039;une requête
   sur un seul serveur, il prend un sens limité en utilisant un serveur
   comme sortie pour les autres filtres pour une réduction future
   de la liste des candidats.
  </p>
  <p class="para">
   Un exemple d&#039;une séquence de filtre qui va échouer:
   <ul class="itemizedlist">
    <li class="listitem">
     <span class="simpara">
      Requête à exécuter : <code class="literal">SELECT 1 FROM DUAL</code>.
      Passé à tous les filtres.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Tous les noeuds configurés sont passés comme entrée au premier filtre.
      Nœuds maîtres : <code class="literal">master_0</code>.
      Nœuds esclaves : <code class="literal">slave_0</code>, <code class="literal">slave_1</code>
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Filtre : <code class="literal">random</code>, argument <code class="literal">sticky=1</code>.
      Sélectionne un esclave aléatoire à utiliser pour le reste des requêtes PHP.
      Sortie : <code class="literal">slave_0</code>.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Sortie de <code class="literal">slave_0</code> et la requête à exécuter
      est passée comme entrée pour le prochain filtre. Ici : <code class="literal">roundrobin</code>,
      liste de serveurs passé au filtre est : <code class="literal">slave_0</code>.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Filtre : <code class="literal">roundrobin</code>. La liste des serveurs consiste
      en un seul serveur, round robin retourne toujours le même serveur.
     </span>
    </li>
   </ul>
   Si vous tentez d&#039;utiliser de telles séquences de filtres, le plugin
   peut émettre une alerte comme <code class="literal">(mysqlnd_ms) Error while creating
   filter &#039;%s&#039; . Non-multi filter &#039;%s&#039; already created. Stopping in %s on
   line %d</code>. Par la suite, une erreur appropriée sur le gestionnaire
   de connexion devrait être définie.
  </p>
  <p class="para">
   Il existe un second type de filtre : le multi filtre. Ce type ressort zéro, un ou plusieurs
    serveurs. Le filtre <code class="literal">quality_of_service</code> en est un exemple. Si la qualité de
    service est réglée avec une limite de retard des esclaves et que plus d&#039;un esclave est victime
    de retard dans la limite, le filtre retourne alors plus d&#039;un noeud. Un filtre multi doit être
    chainé avec un autre pour réduire la liste.
  </p>
  <p class="para">
   Voici une séquence de filtres avec <code class="literal">quality_of_service</code> suivi d&#039;un filtre
   d&#039;équilibre de charge.
   <ul class="itemizedlist">
    <li class="listitem">
     <span class="simpara">
      Requête à exécuter: <code class="literal">SELECT sum(price) FROM orders WHERE order_id = 1</code>.
      Passée à tous les filtres.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Tous les noeuds configurés sont passés en entrée du premier filtre.
      Noeuds maitres: <code class="literal">master_0</code>.
      Noeuds esclaves: <code class="literal">slave_0</code>, <code class="literal">slave_1</code>,
      <code class="literal">slave_2</code>, <code class="literal">slave_3</code>
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Filtre: <code class="literal">quality_of_service</code>, règle: session_consistency (&quot;lit tes écritures&quot;)
      Sortie: <code class="literal">master_0</code>
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Sortie <code class="literal">master_0</code> et la requête à exécuter est passée en entrée du filtre suivant,
      un filtre <code class="literal">roundrobin</code>.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Filtre: <code class="literal">roundrobin</code>. La liste des serveurs ne contient qu&#039;un seul serveur.
      Round robin selectionne <code class="literal">master_0</code>.
     </span>
    </li>
   </ul>
  </p>
  <p class="para">
   Une séquence de filtres ne doit pas se terminer sur un filtre multi, sinon le plugin risque
   d&#039;envoyer un avertissement du type <code class="literal">(mysqlnd_ms) Error in configuration. Last filter is multi
   filter. Needs to be non-multi one. Stopping in %s on line %d</code>.
   Aussi, une erreur sur la connexion risque d&#039;arriver.
  </p>
  <p class="para">
   <blockquote class="note"><p><strong class="note">Note</strong>: 
    <strong>Spéculation sur le futur: Filtres de réplication MySQL</strong><br />
    <p class="para">
     Dans les futures versions, il devrait y avoir plus de filtres multi. Par exemple,
     il devrait exister un filtre <code class="literal">table</code> pour supporter le filtrage
     de réplication MySQL. Le filtre de réplication MySQL vous autorise de définir
     des règles où la base de données ou la table sera répliquée vers un noeud
     précis d&#039;un cluster de réplication. Supposons que votre cluster de
     réplication consiste en 4 esclaves (<code class="literal">slave_0</code>, <code class="literal">slave_1</code>,
     <code class="literal">slave_2</code>, <code class="literal">slave_3</code>), 2 d&#039;entre eux répliquent
     une base de données nommée <code class="literal">sales</code> (<code class="literal">slave_0</code>,
     <code class="literal">slave_1</code>). Si l&#039;application requête la base de données
     <code class="literal">slaves</code>, l&#039;hypothétique filtre <code class="literal">table</code>
     réduit la liste des serveurs possibles à <code class="literal">slave_0</code>,
     <code class="literal">slave_1</code>. En raison du fait que la sortie et que la liste
     des serveurs candidats contient plus d&#039;un serveur, il est nécessaire et possible
     aux futures filtres de filtrer la liste des candidats, par exemple,
     en utilisant le filtre de balance de charge pour identifier un serveur
     pour l&#039;exécution de la requête.
    </p>  
   </p></blockquote>
  </p>
 </div></div></div></body></html>