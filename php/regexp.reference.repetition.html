<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>R&eacute;p&eacute;titions</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

 </head>
 <body class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="regexp.reference.subpatterns.html">« Sous-masques</a></li>
      <li style="float: right;"><a href="regexp.reference.back-references.html">R&eacute;f&eacute;rences arri&egrave;res »</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="reference.pcre.pattern.syntax.html">Fonctionnement des expressions rationnelles</a></li>
    <li>R&eacute;p&eacute;titions</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="regexp.reference.repetition" class="section">
  <h2 class="title">Répétitions</h2>
  <p class="para">
   Les répétitions sont spécifiées avec
   des quantificateurs, qui peuvent être placés à
   la suite des caractères suivants :
   
   <ul class="itemizedlist">
    <li class="listitem"><span class="simpara">Un caractère unique, même s&#039;il s&#039;agit d&#039;un métacaractère</span></li>
    <li class="listitem"><span class="simpara">Le métacaractère . </span></li>
    <li class="listitem"><span class="simpara">Une classe de caractères</span></li>
    <li class="listitem"><span class="simpara">Une référence de retour (voir section suivante)</span></li>
    <li class="listitem"><span class="simpara">Un sous-masque avec parenthèses (à moins que ce ne soit
     une assertion, voir plus loin)</span></li>
   </ul>
  </p>
  <p class="para">
   Les quantificateurs généraux précisent un nombre
   minimum et maximum de répétitions possibles, donnés
   par deux nombres entre accolades, et séparés par une virgule.
   Ces nombres doivent être plus petits que 65536, et le premier nombre
   doit être égal ou inférieur au second. Par exemple
   
   <code class="literal">z{2,4}</code>
   
   accepte &quot;<code class="literal">zz</code>&quot;,
   &quot;<code class="literal">zzz</code>&quot;, ou &quot;<code class="literal">zzzz</code>&quot;. L&#039;accolade fermante
   n&#039;a pas de signification par elle-même.
   Si le second nombre est omis, mais que la virgule est là, cela
   signifie qu&#039;il n&#039;y a pas de limite supérieure. Si le second nombre
   et la virgule sont omis, le quantificateur correspond au nombre exact de
   répétitions attendues. Par exemple :
   
   <code class="literal">[aeiou]{3,}</code>
   
   accepte n&#039;importe quelle succession d&#039;au moins 3 voyelles minuscules, tandis
   que
   
   <code class="literal">\d{8}</code>
   
   n&#039;accepte que 8 chiffres exactement.
   Une accolade ouvrante qui apparaît à une position où
   un quantificateur n&#039;est pas accepté, ou si la syntaxe des
   quantificateurs n&#039;est pas respectée, sera considérée
   littérale. Par exemple, &quot;<code class="literal">{,6}</code>&quot; n&#039;est pas un
   quantificateur, mais une chaîne de 4 caractères.
  </p>
  <p class="para">
   Le quantificateur {0} est autorisé, mais l&#039;expression est alors
   ignorée.
  </p>
  <p class="para">
   Par convenance (et pour la compatibilité ascendante), les trois
   quantificateurs les plus communs ont une abréviation d&#039;un
   seul caractère :
   <table class="doctable table">
    <caption><strong>Quantificateurs sur un seul caractère</strong></caption>
    
     <tbody class="tbody">
      <tr>
       <td><code class="literal">*</code></td>
       <td>équivalent à <code class="literal">{0,}</code></td>
      </tr>

      <tr>
       <td><code class="literal">+</code></td>
       <td>équivalent à <code class="literal">{1,}</code></td>
      </tr>

      <tr>
       <td><code class="literal">?</code></td>
       <td>équivalent à <code class="literal">{0,1}</code></td>
      </tr>

     </tbody>
    
   </table>

  </p>
  <p class="para">
   Il est possible de constituer des boucles infinies en créant un sous-masque
   sans caractères, mais pourvu d&#039;un quantificateur sans limite
   supérieure. Par exemple :
   
   <code class="literal">(a?)*</code>
   
  </p>
  <p class="para">
   Les versions plus anciennes de Perl et PCRE généraient alors
   une erreur au moment de la compilation. Cependant, étant donné
   qu&#039;il existe des situations où ces constructions peuvent être
   utiles, ces masques sont désormais autorisés. Toutefois, si
   la répétition du sous-masque ne trouve aucun caractère,
   la boucle est interrompue.
  </p>
  <p class="para">
   Par défaut, les quantificateurs sont dits &quot;gourmands&quot;, c&#039;est à
   dire, qu&#039;ils cherchent d&#039;abord à trouver le nombre maximal de
   répétitions qui autorisent le succès de la recherche.
   L&#039;exemple classique posé par cette gourmandise est la recherche de
   commentaires d&#039;un programme en C. Les commentaires apparaissent entre les
   séquences <code class="literal">/*....*/</code> et à l&#039;intérieur
   de ces délimiteurs, les <code class="literal">*</code> et <code class="literal">/</code>
   sont autorisés. Appliquer le masque
   
   <code class="literal">/\*.*\*/</code>
   
   à la chaîne
   
   <code class="literal">/* premier commentaire */  aucun commentaire  /* second commentaire */</code>
   
   ne peut réussir, car le masque travaille sur toute la chaîne,
   à cause de la gourmandise du caractère <code class="literal">.*</code>.
  </p>
  <p class="para">
   Cependant, un quantificateur suivi d&#039;un point d&#039;interrogation cesse
   d&#039;être gourmand, et au contraire, ne recherche que le nombre
   minimum de répétition. Dans ces conditions, le masque
   
   <code class="literal">/\*.*?\*/</code>
   
   trouvera bien les commentaires du code
   C. La signification des autres quantificateurs n&#039;est pas changée.
   Attention à ne pas confondre l&#039;utilisation du point d&#039;interrogation
   ici avec son utilisation comme quantificateur lui-même.
   À cause de cette ambiguïté, il peut apparaître des situations
   où il faut le doubler :
   
   <code class="literal">\d??\d</code>
   
   Ce masque va tenter de lire un seul chiffre, mais le cas échéant,
   il acceptera 2 chiffres pour permettre à la recherche d&#039;aboutir.
  </p>
  <p class="para">
   Si l&#039;option <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_UNGREEDY</a>
   est activée, (une option qui n&#039;est pas disponible avec Perl) alors
   les quantificateurs sont non gourmands par défaut, mais peuvent être
   rendu gourmands au cas par cas, en ajoutant un point d&#039;interrogation
   après. En d&#039;autres termes, cette option inverse le comportement par
   défaut.
  </p>
  <p class="para">
   Les quantificateurs suivis par <code class="literal">+</code> sont &quot;possessifs&quot;. Ils
   mangent autant de caractères que possible et ne retournent pas
   pour chercher le reste du masque. <code class="literal">.*abc</code> trouvera 
   <code class="literal">&quot;abc&quot;</code>, tandis que <code class="literal">.*+abc</code> ne le trouvera
   pas, car <code class="literal">.*+</code> accapare totalement la chaîne.
   Les quantificateurs possessifs peuvent être utilisés pour 
   accélérer le traitement.
  </p>
  <p class="para">
   Lorsqu&#039;un sous-masque est quantifié avec un nombre minimum
   de répétitions, qui soit plus grand que 1, ou avec
   un maximum de répétitions, le masque compilé aura
   besoin de plus de place de stockage, proportionnellement au minimum
   et au maximum.
  </p>
  <p class="para">
   Si un masque commence par <code class="literal">.*</code> ou <code class="literal">.{0,}</code>
   et que l&#039;option <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_DOTALL</a>
   (équivalent en Perl à /s) est
   activée, c&#039;est-à-dire en autorisant le remplacement des nouvelles
   lignes par un métacaractère, alors le masque est
   implicitement ancré, car tout ce qui suit va être
   mangé par la première séquence, et se comportera
   comme si le masque se terminait par le métacaractère
   <code class="literal">\A</code>. Dans le cas où on sait d&#039;avance qu&#039;il
   n&#039;y aura pas de caractère de nouvelle ligne, activer l&#039;option
   <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_DOTALL</a> et commencer
   le masque par <code class="literal">.*</code> permet d&#039;optimiser le masque.
   Alternativement, on peut utiliser <code class="literal">^</code> pour ancrer
   explicitement le masque.
  </p>
  <p class="para">
   Lorsqu&#039;un sous-masque capturant est répété, la valeur capturée est la
   dernière. Par exemple, après que
   
   <code class="literal">(inter[net]{3}\s*)+</code>
   
   ait été appliqué à &quot;<code class="literal">internet interne</code>&quot;,
   la valeur de la chaîne capturée est &quot;<code class="literal">interne</code>&quot;.
   Cependant, s&#039;il y a des sous-masques imbriqués, la valeur
   capturée correspondante peut l&#039;avoir été lors
   des précédentes itérations. Par exemple :
   
   <code class="literal">/(a|(b))+/</code>
   
   accepte &quot;<code class="literal">aba</code>&quot; et
   la deuxième valeur capturée est &quot;<code class="literal">b</code>&quot;.
  </p>
 </div></div></div></body></html>