<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Statistiques</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

 </head>
 <body class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="mysqlnd.persist.html">« Les connexions persistantes</a></li>
      <li style="float: right;"><a href="mysqlnd.notes.html">Notes »</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="book.mysqlnd.html">Mysqlnd</a></li>
    <li>Statistiques</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="mysqlnd.stats" class="chapter">
 <h1>Statistiques</h1>

 <p class="para">
  <em class="emphasis">Utilisation des donnés statistiques</em>
 </p>
 <p class="para">
  Le pilote natif MySQL peut collecter des statistiques sur la communication entre
  le client et le serveur. Ces statistiques sont de deux sortes :
 </p>
 <ul class="itemizedlist">
  <li class="listitem">
   <p class="para">
    Les statistiques client
   </p>
  </li>
  <li class="listitem">
   <p class="para">
    Les statistiques de connexion
   </p>
  </li>
 </ul>
 <p class="para">
  Si vous utilisez l&#039;extension <code class="literal">mysqli</code>,
  ces statistiques sont disponibles via deux appels d&#039;API :
 </p>
 <ul class="itemizedlist">
  <li class="listitem">
   <p class="para">
    <span class="function"><a href="function.mysqli-get-client-stats.html" class="function">mysqli_get_client_stats()</a></span>
   </p>
  </li>
  <li class="listitem">
   <p class="para">
    <span class="function"><a href="mysqli.get-connection-stats.html" class="function">mysqli_get_connection_stats()</a></span>
   </p>
  </li>
 </ul>
 <blockquote class="note"><p><strong class="note">Note</strong>: 
  <p class="para">
   Les statistiques sont agrégées entre toutes les extensions qui utilisent
   le pilote natif MySQL. Par exemple, quand les extensions
   <code class="literal">ext/mysql</code> et <code class="literal">ext/mysqli</code>
   sont toutes deux compilées par rapport au pilote natif MySQL, les appels de 
   fonctions de <code class="literal">ext/mysql</code> et <code class="literal">ext/mysqli</code> 
   changeront tous les deux les statistiques. Il n&#039;y a aucun moyen de savoir
   comment des appels à une certaine API compilée par rapport au pilote natif MySQL
   ont modifié une statistique donnée. Vous pouvez configurer le pilote PDO MySQL,
   <code class="literal">ext/mysql</code> et <code class="literal">ext/mysqli</code> pour éventuellement
   utiliser le pilote natif MySQL. Dans ce cas, les trois extensions modifieront les
   statistiques.
  </p>
 </p></blockquote>
 <p class="para">
  <em class="emphasis">Accéder aux statistiques client</em>
 </p>
 <p class="para">
  Pour accéder aux statistiques client, vous devez appeler
  <span class="function"><a href="function.mysqli-get-client-stats.html" class="function">mysqli_get_client_stats()</a></span>. L&#039;appel à la fonction ne requiert
  aucun paramètre.
 </p>
 <p class="para">
  Cette fonction retourne un tableau associatif contenant le nom
  de la statistique comme clé et la donnée statistiques comme valeur.
 </p>
 <p class="para">
  Les statistiques client peuvent aussi être accédées via la fonction
  <span class="function"><a href="function.phpinfo.html" class="function">phpinfo()</a></span>.
 </p>
 <p class="para">
  <em class="emphasis">Accéder aux statistiques de connexion</em>
 </p>
 <p class="para">
  Pour accéder aux statistiques client, vous devez appeler
  <span class="function"><a href="mysqli.get-connection-stats.html" class="function">mysqli_get_connection_stats()</a></span>. Cette fonction prend en paramètre
  la ressource de connexion à la base de données.
 </p>
 <p class="para">
  Cette fonction retourne un tableau associatif contenant le nom de la statistique comme clé
  et la donnée statistique comme valeur.
 </p>
 <p class="para">
  <em class="emphasis">Buffered and Unbuffered Result Sets</em>
 </p>
 <p class="para">
  Les jeux de résultats peuvent être mis ou non en tampon. Le paramétrage par défaut
  fait fonctionner <code class="literal">ext/mysql</code> et <code class="literal">ext/mysqli</code> avec
  des jeux de résultats en tampon pour des requêtes normales (non préparées).
  Les jeux de résultats sont stockés côté client. Après l&#039;exécution de la requête, tous les 
  résultats sont récupérés du serveur MySQL et mis en cache côté client.
  Le grand avantage de jeux de résultat mis en tampon est qu&#039;ils autorisent le serveur à 
  libérer les ressources allouées à un jeu de résultat, dès que ceux-ci ont été récupérés par
  le client.
 </p>
 <p class="para">
  D&#039;autre part, des jeux de résultats non mis en tampon sont gardés plus longtemps sur le serveur.
  Si vous voulez réduire la consommation de mémoire côté client, mais en contre-partie augmenter
  la charge sur le serveur, ne mettez pas les résultats en tampon. Si vous avez par contre une
  charge serveur importante et que vos soupçons se portent sur les résultats non mis en tampon, vous
  devriez considérer de déplacer la charge côté client. Les clients s&#039;adaptent généralement plus 
  facilement que les serveurs. La charge (<q class="quote">Load</q>) ne concerne pas seulement les tampons
  mémoire. En effet, le serveur a aussi besoin de garder d&#039;autres ressources ouvertes, par exemple 
  des threads ou des descripteurs de fichier, avant qu&#039;un jeu de résultat ne soit libéré.
 </p>
 <p class="para">
  Les requêtes préparées ne mettent pas par défaut les résultats en tampon. Vous pouvez 
  toujours utiliser <span class="function"><a href="mysqli-stmt.store-result.html" class="function">mysqli_stmt_store_result()</a></span> pour activer la mise
  en tampon des résultats.
 </p>
 <p class="para">
  <em class="emphasis">Statistiques retournées par le pilote natif MySQL</em>
 </p>
 <p class="para">
  Le tableau suivant présente une liste des statistiques retournées par les fonctions
  <span class="function"><a href="function.mysqli-get-client-stats.html" class="function">mysqli_get_client_stats()</a></span> et
  <span class="function"><a href="mysqli.get-connection-stats.html" class="function">mysqli_get_connection_stats()</a></span>.
 </p>
 <table class="doctable table">
  <caption><strong>Statistiques retournées par mysqlnd : Réseau</strong></caption>
  
   <col width="10*" />
   <col width="10*" />
   <col width="40*" />
   <col width="40*" />
   <thead>
    <tr>
     <th>Statistique</th>
     <th>Contexte</th>
     <th>Description</th>
     <th>Notes</th>
    </tr>

   </thead>

   <tbody class="tbody">
    <tr>
     <td><code class="literal">bytes_sent</code></td>
     <td>Connexion</td>
     <td>Nombre d&#039;octets envoyés de PHP vers le serveur MySQL</td>
     <td>Peut être utilisé pour vérifier l&#039;efficacité du protocole compressé</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received</code></td>
     <td>Connexion</td>
     <td>Nombres d&#039;octets reçus du serveur MySQL</td>
     <td>Peut être utilisé pour vérifier l&#039;efficacité du protocole compressé</td>
    </tr>

    <tr>
     <td><code class="literal">packets_sent</code></td>
     <td>Connexion</td>
     <td>Nombre de paquets envoyés de type client-serveur MySQL</td>
     <td>Utilisé pour déboguer l&#039;implémentation du protocole client-serveur</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received</code></td>
     <td>Connexion</td>
     <td>Nombre de paquets reçus de type client-serveur MySQL</td>
     <td>Utilisé pour déboguer l&#039;implémentation du protocole client-serveur</td>
    </tr>

    <tr>
     <td><code class="literal">protocol_overhead_in</code></td>
     <td>Connexion</td>
     <td>Le surcoût en octets du protocole client-serveur MySQL pour le trafic entrant.
      Actuellement, seul l&#039;en-tête de paquet (4 octets) est considéré comme du
      surcoût. protocol_overhead_in = packets_received * 4</td>
     <td>Utilisé pour déboguer l&#039;implémentation du protocole client-serveur</td>
    </tr>

    <tr>
     <td><code class="literal">protocol_overhead_out</code></td>
     <td>Connexion</td>
     <td>Le surcoût en octets du protocole client-serveur MySQL pour le trafic sortant.
      Actuellement, seul l&#039;en-tête de paquet (4 octets) est considéré comme du
      surcoût. protocol_overhead_in = packets_received * 4</td>
     <td>Utilisé pour déboguer l&#039;implémentation du protocole client-serveur</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_ok_packet</code></td>
     <td>Connexion</td>
     <td>Nombre total d&#039;octets des paquets du protocole client-serveur MySQL reçus avec un statut OK.
      Les paquets reçus avec un statut OK peuvent contenir un message de statut. La longueur de ce message de
      statut peut varier, entrainant de ce fait une taille non-fixe de paquet OK.</td>
     <td>Utilisé pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_ok</code></td>
     <td>Connexion</td>
     <td>Nombre total de paquets du protocole client-serveur MySQL reçus avec un statut OK.</td>
     <td>Utilisé pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_eof_packet</code></td>
     <td>Connexion</td>
     <td>Taille totale en octets des paquets EOF reçus avec le protocole client-serveur MySQL. 
      La taille de EOF peut varier selon la version du serveur.
      De plus, EOF peut contenir un message d&#039;erreur.</td>
     <td>Utilisé pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_eof</code></td>
     <td>Connexion</td>
     <td>Nombre total de paquets EOF reçus avec le protocole client-serveur MySQL.
      Comme avec d&#039;autres statistiques sur les paquets, le nombre de paquets augmentera même si
      PHP ne reçoit pas le paquet attendu, mais par exemple un message d&#039;erreur.</td>
     <td>Utilisé pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_rset_header_packet</code></td>
     <td>Connexion</td>
     <td>Taille totale en octets des paquets d&#039;en-tête de jeux de résultats reçus avec le protocole client-serveur MySQL.
      La taille des paquets varie selon le type de données transportées
      (<code class="literal">LOAD LOCAL INFILE</code>, <code class="literal">INSERT</code>,
      <code class="literal">UPDATE</code>, <code class="literal">SELECT</code>, messages d&#039;erreur).</td>
     <td>Utilisé pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_rset_header</code></td>
     <td>Connexion</td>
     <td>Nombre de paquets d&#039;en-tête de jeux de résultats reçus avec le protocole client-serveur MySQL.</td>
     <td>Utilisé pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_rset_field_meta_packet</code></td>
     <td>Connexion</td>
     <td>Taille totale en octets des paquets de méta-données (informations sur les champs) de jeux de résultats reçus avec
      le protocole client-serveur MySQL. Bien entendu, la taille varie selon les champs contenus dans le jeu de résultats.
      Le paquet peut aussi transporter une erreur ou un EOF dans le cas de COM_LIST_FIELDS.</td>
     <td>Utile seulement pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_rset_field_meta</code></td>
     <td>Connexion</td>
     <td>Nombre de paquets de méta-données (informations sur les champs) de jeux de résultats reçus avec
      le protocole client-serveur MySQL.</td>
     <td>Utile seulement pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_rset_row_packet</code></td>
     <td>Connexion</td>
     <td>Taille totale en octets des paquets de données pures de jeux de résultats reçus avec
      le protocole client-serveur MySQL. Le paquet peut aussi transporter une erreur ou un paquet EOF.
      Vous pouvez faire du rétro-engeneering sur le nombre de paquets d&#039;erreurs ou de paquets EOF en
      soustrayant <code class="literal">rows_fetched_from_server_normal</code>
      et <code class="literal">rows_fetched_from_server_ps</code> de
      <code class="literal">bytes_received_rset_row_packet</code>.</td>
     <td>Utile seulement pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_rset_row</code></td>
     <td>Connexion</td>
     <td>Nombre de paquets de données pures de jeux de résultats reçus avec
      le protocole client-serveur MySQL et leur taille totale en octets.</td>
     <td>Utile seulement pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_prepare_response_packet</code></td>
     <td>Connexion</td>
     <td>Taille totale en octets des paquets &quot;OK for Prepared
      Statement Initialization packets (paquets d&#039;initialisation des commandes préparées).
      Le paquet peut aussi traporter une erreur. La taille du paquet dépend de la version de MySQL :
      9 octets avec MySQL 4.1 et 12 octets à partir de MySQL 5.0. Il n&#039;y a aucun moyen sûr de savoir
      combien d&#039;erreurs sont survenues. Vous pouvez éventuellement deviner qu&#039;une erreur est survenue
      si, par exemple, vous vous connectez toujours à MySQL 5.0 ou supérieur et que 
      <code class="literal">bytes_received_prepare_response_packet</code> !=
      <code class="literal">packets_received_prepare_response</code> * 12. Regardez
      aussi <code class="literal">ps_prepared_never_executed</code> et
      <code class="literal">ps_prepared_once_executed</code>.</td>
     <td>Utile seulement pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_prepare_response</code></td>
     <td>Connexion</td>
     <td>Nombre de paquets &quot;OK for Prepared Statement Initialization packets (paquets d&#039;initialisation des commandes
      préparées).</td>
     <td>Utile seulement pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_change_user_packet</code></td>
     <td>Connexion</td>
     <td>Taille totale en octets des paquets COM_CHANGE_USER reçus avec le protocole client-serveur MySQL.
      Le paquet peut aussi transporter une erreur ou un EOF.</td>
     <td>Utile seulement pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_change_user</code></td>
     <td>Connexion</td>
     <td>Nombre de paquets COM_CHANGE_USER reçus avec le protocole client-serveur MySQL.</td>
     <td>Utile seulement pour déboguer l&#039;implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d&#039;en-tête (4 octets, comme indiqué dans le surcoût du protocole).</td>
    </tr>

    <tr>
     <td><code class="literal">packets_sent_command</code></td>
     <td>Connexion</td>
     <td>Nombre de paquets envoyés de PHP vers MySQL avec le protocole client-serveur MySQL.
      Il n&#039;y a aucun moyen de savoir quelle commande spécifique a été envoyée et en quel quantité.
      Au mieux, vous pouvez vous en servir pour savoir si PHP a envoyé des commandes à MySQL et ainsi
      savoir si vous pouvez supprimer le support de MySQL dans votre binaire PHP. Il n&#039;y a de même aucun
      moyen de faire du rétro-engeneering sur le nombre d&#039;erreurs qui ont pu survenir lors de l&#039;envoi
      de données à MySQL. La seule erreur recodée est command_buffer_too_small (voir ci-après).</td>
     <td>Utile seulement pour déboguer l&#039;implémentation du protocole client-serveur.</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_real_data_normal</code></td>
     <td>Connexion</td>
     <td>Nombre d&#039;octets de charge récupérés par le client PHP depuis
      <code class="literal">mysqlnd</code> en utilisant le protocole de texte.</td>
     <td>C&#039;est la taille des données actuellement contenues dans les jeux de résultats
      qui ne proviennent pas des commandes préparées et qui ont été récupérées par le client
      PHP. Notez que même si un jeu de résultat complet a pu être récupéré de MySQL par
      <code class="literal">mysqlnd</code>, cette statistique ne compte que les données actuellement
      récupérées depuis <code class="literal">mysqlnd</code> par le client PHP. Un exemple de code qui
      incrémentra cette valeur:
      <div class="example-contents">
<div class="cdata"><pre>
$mysqli = new mysqli();
$res = $mysqli-&gt;query(&quot;SELECT &#039;abc&#039;&quot;);
$res-&gt;fetch_assoc();
$res-&gt;close();
</pre></div>
      </div>

      <p class="para">
       Chaque opération de récupération (fetch) incrémentera cette valeur.
      </p>
      
      <p class="para">
       Cette statistique ne sera pas incrémentée si le jeu de résultats est mis en tampon
       seulement sur le client, mais pas récupéré. Par exemple:
      </p>
      <div class="example-contents">
<div class="cdata"><pre>
$mysqli = new mysqli();
$res = $mysqli-&gt;query(&quot;SELECT &#039;abc&#039;&quot;);
$res-&gt;close();
</pre></div>
      </div>

      <p class="para">
       Cette statistique est disponible depuis PHP 5.3.4.
      </p></td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_real_data_ps</code></td>
     <td>Connexion</td>
     <td>Nombre d&#039;octets de charge récupérés par le client PHP depuis
      <code class="literal">mysqlnd</code> en utilisant le protocole de commande préparée.</td>
     <td>C&#039;est la taille des données actuellement contenues dans un jeu de résultats
      provenant d&#039;une commande préparée et qui a été récupérée par le client PHP. La valeur
      ne sera pas incrémentée si le jeu de résultat n&#039;est pas lu par le client PHP. Notez
      que même si un jeu de résultats complet a pu être récupéré depuis MySQL par
      <code class="literal">mysqlnd</code>, cette statistique ne compte que les données récupérées
      par le client PHP depuis <code class="literal">mysqlnd</code>. Voyez aussi
      <code class="literal">bytes_received_real_data_normal</code>. Cette statistique
      est disponible depuis PHP 5.3.4.</td>
    </tr>

   </tbody>
  
 </table>

 <p class="para">
  <em class="emphasis">Jeu de résultats</em>
 </p>
 <table class="doctable table">
  <caption><strong>Statistiques retournées par mysqlnd : Jeu de résultats</strong></caption>
  
   <col width="10*" />
   <col width="10*" />
   <col width="40*" />
   <col width="40*" />
   <thead>
    <tr>
     <th>Statistique</th>
     <th>Contexte</th>
     <th>Description</th>
     <th>Notes</th>
    </tr>

   </thead>

   <tbody class="tbody">
    <tr>
     <td><code class="literal">result_set_queries</code></td>
     <td>Connexion</td>
     <td>Nombre de requêtes qui ont généré un jeu de résultats. Des exemples de requêtes
      qui génèrent un jeu de résultats : <code class="literal">SELECT</code> et
      <code class="literal">SHOW</code>. Cette statistique ne sera pas incrémentée si une erreur survient lors
      de la lecture du paquet d&#039;en-tête du jeu de résultats.</td>
     <td>Vous pouvez l&#039;utiliser comme mesure indirecte du nombre de requêtes que PHP a envoyées
      à MySQL pour identifier, par exemple, un client qui provoque beaucoup de charge sur la base de données.</td>
    </tr>

    <tr>
     <td><code class="literal">non_result_set_queries</code></td>
     <td>Connexion</td>
     <td>Nombre de requêtes qui n&#039;ont pas généré de jeu de résultats. Des exemples de requêtes qui
      ne génèrent pas de jeu de résultats : <code class="literal">INSERT</code>, <code class="literal">UPDATE</code>,
      <code class="literal">LOAD DATA</code>. Cette statistique ne sera pas incrémentée 
      si une erreur survient lors de la lecture du paquet d&#039;en-tête du jeu de résultats.</td>
     <td>Vous pouvez l&#039;utiliser comme mesure indirecte du nombre de requêtes que PHP a envoyées
      à MySQL pour identifier, par exemple, un client qui provoque beaucoup de charge sur la base de données.</td>
    </tr>

    <tr>
     <td><code class="literal">no_index_used</code></td>
     <td>Connexion</td>
     <td>Nombre de requêtes qui ont généré un jeu de résultats mais qui n&#039;ont pas utilisé d&#039;index
      (voir aussi l&#039;option de démarrage de mysqld : 
      –log-queries-not-using-indexes). Si vous voulez que ces requêtes soient rapportées, vous pouvez
      utiliser mysqli_report(MYSQLI_REPORT_INDEX) pour que
      ext/mysqli jette une exception. Si vous préférez un avertissement plutôt qu&#039;une exception, 
      utilisez mysqli_report(MYSQLI_REPORT_INDEX ^
      MYSQLI_REPORT_STRICT).</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">bad_index_used</code></td>
     <td>Connexion</td>
     <td>Nombre de requêtes qui ont généré un jeu de résultats mais qui n&#039;ont pas utilisé un bon index
      (voir aussi l&#039;option de démarrage de mysqld : –log-slow-queries).</td>
     <td>Si vous voulez que ces requêtes soient rapportées, vous pouvez
      utiliser mysqli_report(MYSQLI_REPORT_INDEX) pour que
      ext/mysqli jette une exception. Si vous préférez un avertissement plutôt qu&#039;une exception, 
      utilisez mysqli_report(MYSQLI_REPORT_INDEX ^ MYSQLI_REPORT_STRICT).</td>
    </tr>

    <tr>
     <td><code class="literal">slow_queries</code></td>
     <td>Connexion</td>
     <td>Les commandes SQL qui ont pris plus de <code class="literal">long_query_time</code>
      secondes à être exécutées et qui ont nécessité qu&#039;au moins 
      <code class="literal">min_examined_row_limit</code> enregistrements soient examinés.</td>
     <td>Non reporté par <span class="function"><a href="function.mysqli-report.html" class="function">mysqli_report()</a></span></td>
    </tr>

    <tr>
     <td><code class="literal">buffered_sets</code></td>
     <td>Connexion</td>
     <td>Nombre de jeux de résultats retournés par des requêtes <q class="quote">normales</q> et qui
      ont été mis en tampon. <q class="quote">normale</q> signifie <q class="quote">commande non préparée</q> 
      dans les notes qui suivent.</td>
     <td>Des exemples d&#039;appel à l&#039;API, qui ne mettront pas les jeux de résultats en tampon côté client :
      <span class="function"><a href="function.mysql-query.html" class="function">mysql_query()</a></span>,
      <span class="function"><a href="mysqli.query.html" class="function">mysqli_query()</a></span>,
      <span class="function"><a href="mysqli.store-result.html" class="function">mysqli_store_result()</a></span>,
      <span class="function"><a href="mysqli-stmt.get-result.html" class="function">mysqli_stmt_get_result()</a></span>. Mettre les jeux de résultat en tampon
      côté client assure que les ressources allouées côté serveur sont libérées dès que possible
      et rend la navigation dans le jeu de résultat plus aisée. L&#039;inconvénient, c&#039;est une consommation
      mémoire plus importante côté client pour mettre les jeux de résultats en tampon. Notez que
      mysqlnd (contrairement à la bibliothèque cliente MySQL) respecte la limite de mémoire de PHP pour l&#039;allocation,
      car mysqlnd utilise les fonctions de gestion de mémoire internes de PHP. C&#039;est aussi pourquoi
      <span class="function"><a href="function.memory-get-usage.html" class="function">memory_get_usage()</a></span> rapporte une consommation mémoire plus importante quand on 
      utilise mysqlnd plutôt que la bibliothèque cliente MySQL. <span class="function"><a href="function.memory-get-usage.html" class="function">memory_get_usage()</a></span> ne mesure
      pas la consommation mémoire de la bibliothèque cliente MySQL car celle-ci n&#039;utilise pas les fonctions
      de gestion de mémoire internes de PHP, mésurées par cette fonction!</td>
    </tr>

    <tr>
     <td><code class="literal">unbuffered_sets</code></td>
     <td>Connexion</td>
     <td>Nombre de jeux de résultats non mis en tampon retournés par des requêtes normales
      (pas de commande préparée).</td>
     <td>Des exemples d&#039;appels à l&#039;API qui ne mettent pas les jeux de résultats en tampon côté client :
      <span class="function"><a href="mysqli.use-result.html" class="function">mysqli_use_result()</a></span></td>
    </tr>

    <tr>
     <td><code class="literal">ps_buffered_sets</code></td>
     <td>Connexion</td>
     <td>Nombre de jeux de résultats mis en tampon retournés par des commandes préparées. Par défaut, les commandes
      préparées ne sont pas mises en tampon.</td>
     <td>Des exemples d&#039;appels à l&#039;API qui mettent les jeux de résultats en tampon côté client :
      <code class="literal">mysqli_stmt_store_result</code></td>
    </tr>

    <tr>
     <td><code class="literal">ps_unbuffered_sets</code></td>
     <td>Connexion</td>
     <td>Nombre de jeux de résultats non mis en tampon retournés par des commandes préparées.</td>
     <td>Par défaut, les commandes préparées ne sont pas mises en tampon.</td>
    </tr>

    <tr>
     <td><code class="literal">flushed_normal_sets</code></td>
     <td>Connexion</td>
     <td>Nombre de jeux de résultats issus de requêtes normales (pas de commande préparée) avec des
      données non lues qui ont été évacuées implicitement. L&#039;évacuation n&#039;a lieu qu&#039;avec les jeux de résultats non
      mis en tampon.</td>
     <td>Les jeux de résultats non mis en tampon doivent être récupérés en totalité avant qu&#039;une nouvelle requête
      puisse être passée sur la connexion, sans quoi MySQL renverra une erreur. Si l&#039;application ne récupère pas
      tous les enregistrements d&#039;un jeu de résultats non mis en tampon, mysqlnd récupère implicitement tout le jeu
      afin de laisser place nette. Voir aussi <code class="literal">rows_skipped_normal</code> et 
      <code class="literal">rows_skipped_ps</code>. Quelques causes possibles d&#039;une évacuation implicite :
      <ul class="itemizedlist">
       <li class="listitem">
        <p class="para">
         Une application cliente défectueuse
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         Le client a arrêté de lire après qu&#039;il a trouvé ce qu&#039;il cherchait met a fait considérer à
         MySQL davantage d&#039;enregistrements que nécessaire
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         L&#039;application cliente s&#039;est arrêtée de façon inattendue
        </p>
       </li>
      </ul></td>
    </tr>

    <tr>
     <td><code class="literal">flushed_ps_sets</code></td>
     <td>Connexion</td>
     <td>Nombre de jeux de résultats issus de commandes préparées avec des
      données non lues qui ont été évacuées implicitement. L&#039;évacuation n&#039;a lieu qu&#039;avec les jeux de résultats non
      mis en tampon.</td>
     <td>Les jeux de résultats non mis en tampon doivent être récupérés en totalité avant qu&#039;une nouvelle requête
      puisse être passée sur la connexion, sans quoi MySQL renverra une erreur. Si l&#039;application ne récupère pas
      tous les enregistrements d&#039;un jeu de résultats non mis en tampon, mysqlnd récupère implicitement tout le jeu
      afin de laisser place nette. Voir aussi <code class="literal">rows_skipped_normal</code> et 
      <code class="literal">rows_skipped_ps</code>. Quelques causes possibles d&#039;une évacuation implicite :
      <ul class="itemizedlist">
       <li class="listitem">
        <p class="para">
         Une application cliente défectueuse
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         Le client a arrêté de lire après qu&#039;il a trouvé ce qu&#039;il cherchait met a fait considérer à
         MySQL davantage d&#039;enregistrements que nécessaire
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         L&#039;application cliente s&#039;est arrêtée de façon inattendue
        </p>
       </li>
      </ul></td>
    </tr>

    <tr>
     <td><code class="literal">ps_prepared_never_executed</code></td>
     <td>Connexion</td>
     <td>Nombre de commandes préparées mais jamais exécutées.</td>
     <td>Les commandes préparées monopolisent des ressources serveur. Vous ne devriez pas préparer une
      commande si vous n&#039;envisagez pas de l&#039;exécuter.</td>
    </tr>

    <tr>
     <td><code class="literal">ps_prepared_once_executed</code></td>
     <td>Connexion</td>
     <td>Nombre de commandes préparées exécutées une seule fois.</td>
     <td>Un des principes des commandes préparées est que la même requête est
      exécutée encore et encore (avec des paramètres différents) de telle façon que
      des opérations d&#039;analyse syntaxique et de préparation puissent être économisées si
      l&#039;exécution de la commande est séparée en deux phases distinctes de préparation et
      d&#039;exécution. L&#039;idée est de préparer une fois et de mettre en <q class="quote">cache</q> les
      résultats pour que, par exemple, l&#039;arbre d&#039;analyse syntaxique puisse être réutilisé pour
      l&#039;exécution de plusieurs commandes. Si vous exécutez une commande préparée uen seule fois,
      vous perdez tous le bénéfice des deux phases distinctes par rapport à des requêtes 
      <q class="quote">normales</q> parce que la mise en cache représente du travail supplémentaire et 
      monopolise des ressources (limitées) côté serveur. Par conséquent, les commandes préparées
      exécutées une seule fois peuvent provoquer des baisses de performance.</td>
    </tr>

    <tr>
     <td><code class="literal">rows_fetched_from_server_normal</code>,
      <code class="literal">rows_fetched_from_server_ps</code></td>
     <td>Connexion</td>
     <td>Nombre total de jeux de résultats récupérés avec succès du serveur MySQL sans se soucier
      si l&#039;application cliente les a utilisés ou pas.
      Certains des enregistrements peuvent ne pas avoir été récupérés par l&#039;application cliente mais
      avoir été évacués de façon implicite.</td>
     <td>Voir aussi <code class="literal">packets_received_rset_row</code></td>
    </tr>

    <tr>
     <td><code class="literal">rows_buffered_from_client_normal</code>,
      <code class="literal">rows_buffered_from_client_ps</code></td>
     <td>Connexion</td>
     <td>Nombre total d&#039;enregistrements mis en tampon avec succès suite à une requête
      <q class="quote">normale</q> ou une commande préparée. C&#039;est le nombre d&#039;enregistrements
      qui ont été récupérés du serveur MySQL et mis en tampon par le client. Notez qu&#039;il y
      a deux statistiques différentes : une sur les enregistrements ont été mis en tampon
      (de MySQL au tampon interne de mysqlnd) et l&#039;autre sur les enregistrements mis en tampon
      qui ont été récupérés par l&#039;application cliente (du tampon interne de mysqlnd vers l&#039;application
      cliente). Si le nombre d&#039;enregistrements mis en tampon est supérieur au nombre d&#039;enregistrements
      récupérés, cela peut signifier que l&#039;application cliente exécute des requêtes dont les
      enregistrements résultants sont plus grands que nécessaire, menant à des enregistrements non
      lus par le client.</td>
     <td>Des exemples de requêtes qui mettent les résultats en tampon :
      <span class="function"><a href="mysqli.query.html" class="function">mysqli_query()</a></span>,
      <span class="function"><a href="mysqli.store-result.html" class="function">mysqli_store_result()</a></span></td>
    </tr>

    <tr>
     <td><code class="literal">rows_fetched_from_client_normal_buffered</code>,
      <code class="literal">rows_fetched_from_client_ps_buffered</code></td>
     <td>Connexion</td>
     <td>Nombre total d&#039;enregistrements récupérés par le client à partir d&#039;un jeu de résultat
      mis en tampon et créé à partir d&#039;une requête <q class="quote">normale</q> ou d&#039;une commande préparée.</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">rows_fetched_from_client_normal_unbuffered</code>,
      <code class="literal">rows_fetched_from_client_ps_unbuffered</code></td>
     <td>Connexion</td>
     <td>Nombre total d&#039;enregistrements récupérés par le client à partir d&#039;un jeu de résultat
      non mis en tampon et créé à partir d&#039;une requête <q class="quote">normale</q> ou d&#039;une commande préparée.</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">rows_fetched_from_client_ps_cursor</code></td>
     <td>Connexion</td>
     <td>Nombre total d&#039;enregistrements récupérés par le client à partir d&#039;un curseur créé
      par une commande préparée.</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">rows_skipped_normal</code>,
      <code class="literal">rows_skipped_ps</code></td>
     <td>Connexion</td>
     <td>Reservé pour une utilisation future (actuellement non supporté)</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">copy_on_write_saved</code>,
      <code class="literal">copy_on_write_performed</code></td>
     <td>Processus</td>
     <td>Avec mysqlnd, les variables retournées par l&#039;extension pointent vers les tampons
      de résultats réseau internes à mysqlnd. Si vous en changez pas ces variables, les données
      récupérées seront gardées une seule fois en mémoire. Si vous changez les variables,
      mysqlnd doit faire une copie-avant-écriture (copy-on-write) pour protéger ces tampons de
      résultats réseau internes. Avec la bibliothèque cliente MySQL, vous gardez toujours les données
      récupérées en mémoire en deux exemplaires : un pour les tampons internes à la bibliothèque cliente
      MySQL et un pour les extensions. En théorie, mysqlnd peut vous faire économiser jusqu&#039;à 40% de mémoire.
      Notez cependant que l&#039;économie de mémoire ne peut pas être mésurée par
      <span class="function"><a href="function.memory-get-usage.html" class="function">memory_get_usage()</a></span>.</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">explicit_free_result</code>,
      <code class="literal">implicit_free_result</code></td>
     <td>Connexion, Process (seulement pendant le ménage des commandes préparées)</td>
     <td>Nombre total de jeux de résultats libérés.</td>
     <td>La libération est toujours considérée comme explicite, sauf pour les jeux de résultats créés
      par des commandes d&#039;initialisation, par exemple 
      <code class="literal">mysqli_options(MYSQLI_INIT_COMMAND , ...)</code></td>
    </tr>

    <tr>
     <td><code class="literal">proto_text_fetched_null</code>,
      <code class="literal">proto_text_fetched_bit</code>,
      <code class="literal">proto_text_fetched_tinyint</code>
      <code class="literal">proto_text_fetched_short</code>,
      <code class="literal">proto_text_fetched_int24</code>,
      <code class="literal">proto_text_fetched_int</code>
      <code class="literal">proto_text_fetched_bigint</code>,
      <code class="literal">proto_text_fetched_decimal</code>,
      <code class="literal">proto_text_fetched_float</code>
      <code class="literal">proto_text_fetched_double</code>,
      <code class="literal">proto_text_fetched_date</code>,
      <code class="literal">proto_text_fetched_year</code>
      <code class="literal">proto_text_fetched_time</code>,
      <code class="literal">proto_text_fetched_datetime</code>,
      <code class="literal">proto_text_fetched_timestamp</code>
      <code class="literal">proto_text_fetched_string</code>,
      <code class="literal">proto_text_fetched_blob</code>,
      <code class="literal">proto_text_fetched_enum</code>
      <code class="literal">proto_text_fetched_set</code>,
      <code class="literal">proto_text_fetched_geometry</code>,
      <code class="literal">proto_text_fetched_other</code></td>
     <td>Connexion</td>
     <td>Nombre total de colonnes d&#039;un certain type retournées à partir d&#039;une requête normale 
      (protocole texte MySQL).</td>
     <td>Correspondance entre l&#039;API C / les types de méta-données MySQL et le nom des statistiques :
      <ul class="itemizedlist">
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_NULL</code> - proto_text_fetched_null
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_BIT</code> - proto_text_fetched_bit
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_TINY</code> - proto_text_fetched_tinyint
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_SHORT</code> - proto_text_fetched_short
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_INT24</code> - proto_text_fetched_int24
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_LONG</code> - proto_text_fetched_int
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_LONGLONG</code> -
         proto_text_fetched_bigint
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_DECIMAL</code>,
         <code class="literal">MYSQL_TYPE_NEWDECIMAL</code> -
         proto_text_fetched_decimal
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_FLOAT</code> - proto_text_fetched_float
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_DOUBLE</code> -
         proto_text_fetched_double
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_DATE</code>,
         <code class="literal">MYSQL_TYPE_NEWDATE</code> - proto_text_fetched_date
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_YEAR</code> - proto_text_fetched_year
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_TIME</code> - proto_text_fetched_time
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_DATETIME</code> -
         proto_text_fetched_datetime
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_TIMESTAMP</code> -
         proto_text_fetched_timestamp
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_STRING</code>,
         <code class="literal">MYSQL_TYPE_VARSTRING</code>,
         <code class="literal">MYSQL_TYPE_VARCHAR</code> -
         proto_text_fetched_string
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_TINY_BLOB</code>,
         <code class="literal">MYSQL_TYPE_MEDIUM_BLOB</code>,
         <code class="literal">MYSQL_TYPE_LONG_BLOB</code>,
         <code class="literal">MYSQL_TYPE_BLOB</code> - proto_text_fetched_blob
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_ENUM</code> - proto_text_fetched_enum
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_SET</code> - proto_text_fetched_set
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_GEOMETRY</code> -
         proto_text_fetched_geometry
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         N&#039;importe quel <code class="literal">MYSQL_TYPE_*</code> non encore listé (il ne doit y en avoir
         aucun) - proto_text_fetched_other
        </p>
       </li>
      </ul>
      <p class="para">
       A noter que les constantes de type MYSQL_* peuvent ne pas être associées avec le même type
       de colonne SQL dans toutes les versions de MySQL.
      </p></td>
    </tr>

    <tr>
     <td><code class="literal">proto_binary_fetched_null</code>,
      <code class="literal">proto_binary_fetched_bit</code>,
      <code class="literal">proto_binary_fetched_tinyint</code>
      <code class="literal">proto_binary_fetched_short</code>,
      <code class="literal">proto_binary_fetched_int24</code>,
      <code class="literal">proto_binary_fetched_int</code>,
      <code class="literal">proto_binary_fetched_bigint</code>,
      <code class="literal">proto_binary_fetched_decimal</code>,
      <code class="literal">proto_binary_fetched_float</code>,
      <code class="literal">proto_binary_fetched_double</code>,
      <code class="literal">proto_binary_fetched_date</code>,
      <code class="literal">proto_binary_fetched_year</code>,
      <code class="literal">proto_binary_fetched_time</code>,
      <code class="literal">proto_binary_fetched_datetime</code>,
      <code class="literal">proto_binary_fetched_timestamp</code>,
      <code class="literal">proto_binary_fetched_string</code>,
      <code class="literal">proto_binary_fetched_blob</code>,
      <code class="literal">proto_binary_fetched_enum</code>,
      <code class="literal">proto_binary_fetched_set</code>,
      <code class="literal">proto_binary_fetched_geometry</code>,
      <code class="literal">proto_binary_fetched_other</code></td>
     <td>Connexion</td>
     <td>Nombre total de colonnes d&#039;un certain type retournées à partir d&#039;une commande préparée 
      (protocole binaire MySQL).</td>
     <td>Pour la correspondance des types, regardez <code class="literal">proto_text_*</code> décrit ci-dessus.</td>
    </tr>

   </tbody>
  
 </table>

 <table class="doctable table">
  <caption><strong>Statistiques retournées par mysqlnd : Connexion</strong></caption>
  
   <col width="10*" />
   <col width="10*" />
   <col width="40*" />
   <col width="40*" />
   <thead>
    <tr>
     <th>Statistique</th>
     <th>Contexte</th>
     <th>Description</th>
     <th>Notes</th>
    </tr>

   </thead>

   <tbody class="tbody">
    <tr>
     <td><code class="literal">connect_success</code>, <code class="literal">connect_failure</code></td>
     <td>Connexion</td>
     <td>Nombre total de tentatives de connexions réussies / échouées.</td>
     <td>Les connexions réutilisées et tous les autres types de connexions sont incluses.</td>
    </tr>

    <tr>
     <td><code class="literal">reconnect</code></td>
     <td>Processus</td>
     <td>Nombre total de tentatives de (real_)connect faites sur un descripteur de connexion déjà 
      ouvert.</td>
     <td>Le code <code class="literal">$link = new mysqli(...);
      $link-&gt;real_connect(...)</code> provoquera une reconnexion. Ce qui n&#039;est pas le cas de 
      <code class="literal">$link = new mysqli(...); $link-&gt;connect(...)</code>
      car <code class="literal">$link-&gt;connect(...)</code> fermera explicitement la connexion existante 
      avant qu&#039;une nouvelle connexion soit établie.</td>
    </tr>

    <tr>
     <td><code class="literal">pconnect_success</code></td>
     <td>Connexion</td>
     <td>Nombre total de tentatives de connexions persistantes réussies.</td>
     <td>Notez que <code class="literal">connect_success</code> contient la somme des tentatives de 
      connexions persistantes et non-persistantes réussies. Ainsi, le nombre de tentatives de 
      connexions non-persistantes réussies est
      <code class="literal">connect_success</code> -
      <code class="literal">pconnect_success</code>.</td>
    </tr>

    <tr>
     <td><code class="literal">active_connections</code></td>
     <td>Connexion</td>
     <td>Nombre total de connexions persistantes et non-persistantes actives.</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">active_persistent_connections</code></td>
     <td>Connexion</td>
     <td>Nombre total de connexions persistantes actives.</td>
     <td>Le nombre total de connexions non-persistantes actives est
      <code class="literal">active_connections</code> -
      <code class="literal">active_persistent_connections</code>.</td>
    </tr>

    <tr>
     <td><code class="literal">explicit_close</code></td>
     <td>Connexion</td>
     <td>Nombre total de connexions fermées explicitement (seulement valable avec ext/mysqli).</td>
     <td>Des exemples de code qui ferment explicitement une connexion :
      <div class="example-contents">
<div class="cdata"><pre>
$link = new mysqli(...); $link-&gt;close(...)
$link = new mysqli(...); $link-&gt;connect(...)
</pre></div>
      </div>
</td>
    </tr>

    <tr>
     <td><code class="literal">implicit_close</code></td>
     <td>Connexion</td>
     <td>Nombre total de connexions fermées implicitement (seulement valable avec ext/mysqli).</td>
     <td>Des exemples de code qui ferment implicitement une connexion :
      <ul class="itemizedlist">
       <li class="listitem">
        <p class="para">
         <code class="literal">$link = new mysqli(...);
          $link-&gt;real_connect(...)</code>
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">unset($link)</code>
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         Connexions persistantes : le groupe de connexions qui ont été créées avec
         real_connect et où il peut y avoir des jeu d&#039;options inconnues - ferme implicitement
         la connexion pour éviter de retourner une connexion avec des options inconnues
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         Connexions persistantes : ping/change_user échoue et ext/mysqli
         ferme la connexion
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         Fin de l&#039;exécution d&#039;un script : ferme la connexion qui ne l&#039;a pas été par 
         l&#039;utilisateur
        </p>
       </li>
      </ul></td>
    </tr>

    <tr>
     <td><code class="literal">disconnect_close</code></td>
     <td>Connexion</td>
     <td>Echecs de connexions indiqués par l&#039;appel à l&#039;API C
      <span class="function"><strong>mysql_real_connect()</strong></span> pendant la tentative de connexion.</td>
     <td>Elle est appelée <code class="literal">disconnect_close</code> parce que le descripteur de connexion
      passé lors de l&#039;appel à l&#039;API C sera fermé.</td>
    </tr>

    <tr>
     <td><code class="literal">in_middle_of_command_close</code></td>
     <td>Processus</td>
     <td>Une connexion a été fermée en plein milieu de l&#039;exécution d&#039;une commande
      (excluant les jeux de résultats non récupérés, après avoir envoyé une requête et
      avant d&#039;avoir la réponse, en envoyant des données, en transférant des données
      avec LOAD DATA).</td>
     <td>A moins que vous n&#039;utilisiez les requêtes asynchrones, ceci ne devrait arriver que si votre script
      s&#039;arrête de façon inopinée et que PHP ferme la connexion pour vous.</td>
    </tr>

    <tr>
     <td><code class="literal">init_command_executed_count</code></td>
     <td>Connexion</td>
     <td>Nombre total d&#039;exécution de commandes d&#039;initialisation, par exemple,
      <code class="literal">mysqli_options(MYSQLI_INIT_COMMAND , ...)</code>.</td>
     <td>Le nombre de connexions avec succès est
      <code class="literal">init_command_executed_count</code> -
      <code class="literal">init_command_failed_count</code>.</td>
    </tr>

    <tr>
     <td><code class="literal">init_command_failed_count</code></td>
     <td>Connexion</td>
     <td>Nombre total d&#039;exécution échouées de commandes d&#039;initialisation.</td>
     <td class="empty">&nbsp;</td>
    </tr>

   </tbody>
  
 </table>

 <table class="doctable table">
  <caption><strong>Statistiques retournées par mysqlnd : Commande COM_*</strong></caption>
   
    <col width="10*" />
    <col width="10*" />
    <col width="40*" />
    <col width="40*" />
    <thead>
     <tr>
      <th>Statistique</th>
      <th>Contexte</th>
      <th>Description</th>
      <th>Notes</th>
     </tr>

    </thead>

    <tbody class="tbody">
     <tr>
      <td><code class="literal">com_quit</code>, <code class="literal">com_init_db</code>,
       <code class="literal">com_query</code>, <code class="literal">com_field_list</code>,
       <code class="literal">com_create_db</code>, <code class="literal">com_drop_db</code>,
       <code class="literal">com_refresh</code>, <code class="literal">com_shutdown</code>,
       <code class="literal">com_statistics</code>,
       <code class="literal">com_process_info</code>,
       <code class="literal">com_connect</code>,
       <code class="literal">com_process_kill</code>, <code class="literal">com_debug</code>,
       <code class="literal">com_ping</code>, <code class="literal">com_time</code>,
       <code class="literal">com_delayed_insert</code>,
       <code class="literal">com_change_user</code>,
       <code class="literal">com_binlog_dump</code>,
       <code class="literal">com_table_dump</code>,
       <code class="literal">com_connect_out</code>,
       <code class="literal">com_register_slave</code>,
       <code class="literal">com_stmt_prepare</code>,
       <code class="literal">com_stmt_execute</code>,
       <code class="literal">com_stmt_send_long_data</code>,
       <code class="literal">com_stmt_close</code>,
       <code class="literal">com_stmt_reset</code>,
       <code class="literal">com_stmt_set_option</code>,
       <code class="literal">com_stmt_fetch</code>, <code class="literal">com_daemon</code></td>
      <td>Connexion</td>
      <td>Nombre total de tentatives d&#039;envoi d&#039;une certaine commande COM_* command de PHP vers
       MySQL.</td>
      <td><p class="para">
       Les statistiques sont incrémentées après avoir vérifié la connexion et immédiatement
       avant d&#039;envoyer le paquet correspondant du protocole client-serveur MySQL. Si mysqlnd
       échoue lors de l&#039;envoi du paquet via la connexion, la statistique ne sera pas décrémentée.
       En cas d&#039;échec, mysqlnd émet un avertissement PHP <q class="quote">Error while sending %s packet.
       PID=%d.</q>
       </p>
       
       <p class="para">
        Exemples d&#039;utilisation :
       </p>
       <ul class="itemizedlist">
        <li class="listitem">
         <p class="para">
          Vérifie si PHP envoie certaines commandes à MySQL, vérifie par exemple si un client
          envoie <code class="literal">COM_PROCESS_KILL</code>
         </p>
        </li>
        <li class="listitem">
         <p class="para">
          Calcule le nombre moyen d&#039;exécution de commandes préparées en
          comparant <code class="literal">COM_EXECUTE</code> et <code class="literal">COM_PREPARE</code>
         </p>
        </li>
        <li class="listitem">
         <p class="para">
          Vérifie si PHP a envoyé des commandes SQL non préparées en vérifiant si
          <code class="literal">COM_QUERY</code> vaut zéro
         </p>
        </li>
        <li class="listitem">
         <p class="para">
          Identifie si des scripts PHP utilisent un nombre excessif de requêtes SQL en
          vérifiant <code class="literal">COM_QUERY</code> et
          <code class="literal">COM_EXECUTE</code>
         </p>
        </li>
       </ul></td>
     </tr>

    </tbody>
   
  </table>

  <p class="para">
   <em class="emphasis">Divers</em>
  </p>
  <table class="doctable table">
  <caption><strong>Statistiques retournées par mysqlnd : Divers</strong></caption>
   
    <col width="10*" />
    <col width="10*" />
    <col width="40*" />
    <col width="40*" />
    <thead>
     <tr>
      <th>Statistique</th>
      <th>Contexte</th>
      <th>Description</th>
      <th>Notes</th>
     </tr>

    </thead>

    <tbody class="tbody">
     <tr>
      <td><code class="literal">explicit_stmt_close</code>,
       <code class="literal">implicit_stmt_close</code></td>
      <td>Processus</td>
      <td>Nombre total de fermetures de commandes préparées.</td>
      <td>Une fermeture est toujours considérée comme explicite sauf dans le cas d&#039;une préparation échouée.</td>
     </tr>

     <tr>
      <td><code class="literal">mem_emalloc_count</code>,
       <code class="literal">mem_emalloc_ammount</code>,
       <code class="literal">mem_ecalloc_count</code>,
       <code class="literal">mem_ecalloc_ammount</code>,
       <code class="literal">mem_erealloc_count</code>,
       <code class="literal">mem_erealloc_ammount</code>,
       <code class="literal">mem_efree_count</code>,
       <code class="literal">mem_malloc_count</code>,
       <code class="literal">mem_malloc_ammount</code>,
       <code class="literal">mem_calloc_count</code>,
       <code class="literal">mem_calloc_ammount</code>,
       <code class="literal">mem_realloc_count</code>,
       <code class="literal">mem_realloc_ammount</code>,
       <code class="literal">mem_free_count</code></td>
      <td>Processus</td>
      <td>Appels à la gestion de la mémoire.</td>
      <td>Seulement pour du développement.</td>
     </tr>

     <tr>
      <td><code class="literal">command_buffer_too_small</code></td>
      <td>Connexion</td>
      <td>Nombre d&#039;extension de tampon de commandes réseau lors de l&#039;envoi des commandes de
       PHP vers MySQL.</td>
      <td><p class="para">
       mysqlnd alloue un tampon interne de commande/réseau de
       <code class="literal">mysqlnd.net_cmd_buffer_size</code>
       (<var class="filename">php.ini</var>) octets pour chaque connexion. Si une commande du
       protocole client-serveur MySQL, para exemple,
       <code class="literal">COM_QUERY</code> (requête normales), ne rentre pas dans 
       le tampon, mysqlnd étendra le tampon de jusqu&#039;à ce qui est nécessaire pour
       envoyer la commande. Quand le tampon est étendu pour une connexion,
       <code class="literal">command_buffer_too_small</code> sera incrémenté d&#039;une unité.
       </p>
       
       <p class="para">
        Si mysqlnd doit étendre le tampon au délà de sa taille initiale de
        <code class="literal">mysqlnd.net_cmd_buffer_size</code>
        (<var class="filename">php.ini</var>) octets pour la plupart des connexions,
        vous devriez considérer l&#039;augmentation de la taille par défaut pour éviter les 
        you should consider to increase the default size to avoid
        re-allocations.
       </p>
       
       <p class="para">
        La taille par défaut du tampon est de 2048 octets en PHP 5.3.0. Dans les versions
        futures, ce sera 4ko ou plus par défaut. Cette valeur peut être changée soit via 
        <var class="filename">php.ini</var> en ajustant le paramètre
        <code class="literal">mysqlnd.net_cmd_buffer_size</code> ou en utilisant
        <code class="literal">mysqli_options(MYSQLI_OPT_NET_CMD_BUFFER_SIZE, int
         size)</code>.
       </p>
       
       <p class="para">
        Il est recommandé de ne pas ajuster la taille du tampon en dessous de 4096
        octets car mysqlnd l&#039;utilise aussi pour lire certains paquets de communication
        de MySQL. En PHP 5.3.0, mysqlnd n&#039;étendra pas le tampon si MySQL envoie un paquet 
        plus grand que la taille courante du tampon. Par conséquent, mysqlnd n&#039;est pas 
        capable de décoder le paquet et l&#039;application cliente recevra une erreur.
        Il y a seulement deux situations où le paquet peut être plus grand que la valeur
        par défaut de 2048 octets de
        <code class="literal">mysqlnd.net_cmd_buffer_size</code> en PHP 5.3.0 : le
        paquet transporte un message d&#039;erreur très long ou le paquet gère des méta-données de 
        colonne de <code class="literal">COM_LIST_FIELD</code>
        (<span class="function"><a href="function.mysql-list-fields.html" class="function">mysql_list_fields()</a></span>) et les méta-données viennent d&#039;une chaine de 
        caractères avec une valeur par défaut importante (plus de 1900
        octets). Aucun rapport de bogue n&#039;existe sur le sujet - ça doit arriver très rarement.
       </p>
       
       <p class="para">
        Depuis PHP 5.3.2, mysqlnd n&#039;autorise pas les tampons de moins de
        4096 octets.
       </p></td>
     </tr>

     <tr>
      <td><code class="literal">connection_reused</code></td>
      <td class="empty">&nbsp;</td>
      <td class="empty">&nbsp;</td>
      <td class="empty">&nbsp;</td>
     </tr>

    </tbody>
   
  </table>

 </div>
</div></div></body></html>