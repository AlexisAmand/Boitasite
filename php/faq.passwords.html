<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Hashage de mots de passe s&ucirc;r</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

 </head>
 <body class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="faq.using.html">« Utiliser PHP</a></li>
      <li style="float: right;"><a href="faq.html.html">PHP et HTML »</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="faq.html">FAQ</a></li>
    <li>Hashage de mots de passe s&ucirc;r</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="faq.passwords" class="chapter">
 <h1>Hashage de mots de passe sûr</h1>

 
 
 <p class="para">
  Cette section explique les raisons d&#039;utiliser des fonctions de hashage pour les
  mots de passe, ainsi que la façon de le faire efficacement.
 </p>
 
 <div class="qandaset"><ol class="qandaset_questions"><li><a href="#faq.passwords.hashing">
    
     Pourquoi devrais-je hasher les mots de passe envoy&eacute;s par les utilisateurs de mon application ?
    
   </a></li><li><a href="#faq.passwords.fasthash">
    
     Pourquoi les fonctions traditionnelles de hashage comme md5 et
     sha1 sont-elles inappropri&eacute;es aux mots de passe ?
    
   </a></li><li><a href="#faq.passwords.bestpractice">
    
     Alors, comment hasher mes mots de passe ?
    
   </a></li><li><a href="#faq.passwords.salt">
    
     Qu&#039;est ce que le grain de sel ?
    
   </a></li><li><a href="#faq.password.storing-salts">
     
      Comment stocker mes salts ?
     
    </a></li></ol></div>
  <dl class="qandaentry" id="faq.passwords.hashing">
   <dt><strong>
    
     Pourquoi devrais-je hasher les mots de passe envoyés par les utilisateurs de mon application ?
    
   </strong></dt>
   <dd class="answer">
    <p class="para">
     Le hashage de mot de passe est l&#039;une des pratiques de sécurité les plus
     basiques qui doit être effectuée. Sans cela, chaque mot de passe stocké
     peut être volé si le support de stockage (typiquement une base de données)
     est compromis. Ce mot de passe peut alors être immédiatement utilisé pour
     accéder frauduleusement non seulement à votre application mais aussi sur
     d&#039;autres applications si l&#039;utilisateur utilise le même mot de passe ailleurs.
    </p>
    <p class="para">
     En appliquant un hashage sur le mot de passe avant de le stocker, vous rendez
     la tâche d&#039;un attaquant très difficile pour connaitre le mot de passe original,
     et vous avez toujours la possibilité de comparer le mot de passe hashé à une chaîne
     reçue.
    </p>
    <p class="para">
     Il est important de noter que le hashage ne fait que protéger les mots de passe
     dans la base, pas leur éventuelle interception alors qu&#039;ils sont envoyés à
     l&#039;application par l&#039;utilisateur, via du code malicieux injecté dans l&#039;application,
     par exemple.
    </p>
   </dd>
  </dl>
  <dl class="qandaentry" id="faq.passwords.fasthash">
   <dt><strong>
    
     Pourquoi les fonctions traditionnelles de hashage comme <span class="function"><a href="function.md5.html" class="function">md5()</a></span> et
     <span class="function"><a href="function.sha1.html" class="function">sha1()</a></span> sont-elles inappropriées aux mots de passe ?
    
   </strong></dt>
   <dd class="answer">
    <p class="para">
     Les algorithmes de hashage comme MD5, SHA1 et SHA256 sont destinés à être rapides et
     efficaces. Avec les équipements informatiques modernes, il est devenu facile d&#039;attaquer
     par force brute la sortie de ces algorithmes pour retrouver la chaîne originale.
    </p>
    <p class="para">
     C&#039;est la raison pour laquelle de nombreux experts en sécurité considèrent ces algorithmes
     comme faibles et les déconseillent fortement pour hasher un mot de passe utilisateur.
    </p>
   </dd>
  </dl>
  <dl class="qandaentry" id="faq.passwords.bestpractice">
   <dt><strong>
    
     Alors, comment hasher mes mots de passe ?
    
   </strong></dt>
   <dd class="answer">
    <p class="para">
     Lorsqu&#039;on hashe des mots de passe, les deux considérations les plus importantes sont le temps
     de traitement, et le grain de sel. Plus la puissance de traitement requise est élevée, plus
     il faudra du temps pour casser le mot de passe en analysant sa sortie.
    </p>
    <p class="para">
     PHP 5.5 fournit <a href="book.password.html" class="link">une API native de hashage de mot
     de passe</a> qui gère à la fois le
     <a href="function.password-hash.html" class="link">hashage</a> et la
     <a href="function.password-verify.html" class="link">vérification de mots de passe</a>,
     le tout, de manière totalement sécurisée. Il existe aussi une
     <a href="https://github.com/ircmaxell/password_compat" class="link external">&raquo;&nbsp;bibliothèque pure PHP de compatibilité</a>
     pour PHP 5.3.7 et suivants.
    </p>
    <p class="para">
     Une autre option est la fonction <span class="function"><a href="function.crypt.html" class="function">crypt()</a></span>, qui supporte
     différents algorithmes de hashage en PHP 5.3 et suivants. Lors de
     l&#039;utilisation de cette fonction, vous avez la garantie que l&#039;algorithme
     sélectionné est disponible, sachant que PHP contient une implémentation
     native de chaque algorithme supporté, dans le cas où un ou plusieurs
     algorithmes n&#039;est pas supporté par votre système.
    </p>
    <p class="para">
     L&#039;algorithme suggéré à utiliser pour le hashage de mots de passe est
     Blowfish, qui est aussi l&#039;algorithme par défaut de l&#039;API de hashage de mots
     de passe, sachant qu&#039;il est significativement plus gourmand en calcul que
     MD5 ou SHA1, mais plus évolutif.
    </p>
    <p class="para">
     Notez que si vous utilisez la fonction <span class="function"><a href="function.crypt.html" class="function">crypt()</a></span>
     pour vérifier un mot de passe, vous devez faire attention aux attaques
     de synchronisation, en utilisant une constante de temps pour la comparaison.
     Ni les <a href="language.operators.comparison.html" class="link">opérateurs == et === </a>
     ni la fonction <span class="function"><a href="function.strcmp.html" class="function">strcmp()</a></span> n&#039;effectuent de comparaisons en utilisant
     des constantes de temps. Sachant que la fonction <span class="function"><a href="function.password-verify.html" class="function">password_verify()</a></span>
     le fera pour vous, vous êtes vivement encouragé à utiliser
     <a href="book.password.html" class="link">l&#039;API native de hashage de mots de passe</a>
     lorsque vous le pouvez.
    </p>
   </dd>
  </dl>
  <dl class="qandaentry" id="faq.passwords.salt">
   <dt><strong>
    
     Qu&#039;est ce que le grain de sel ?
    
   </strong></dt>
   <dd class="answer">
    <p class="para">
     Un grain de sel, ou &quot;salt&quot;, en cryptographie, est appliqué durant le processus de hashage pour
     éliminer la possibilité d&#039;attaques par dictionnaires (hashages enregistrés dans
     une grande liste et comparés).
    </p>
    <p class="para">
     En d&#039;autres termes, un grain de sel est une petite donnée additionnelle qui
     renforce significativement la puissance du hashage pour le rendre beaucoup plus
     difficile à cracker. Il existe de nombreux services en ligne qui proposent de volumineux
     dictionnaires de mots de passe avec leur hash. L&#039;utilisation d&#039;un
     grain de sel rend ces dictionnaires inutiles.
    </p>
    <p class="para">
     <span class="function"><a href="function.password-hash.html" class="function">password_hash()</a></span> va créer un salt aléatoire si vous n&#039;en fournissez
     pas, et c&#039;est généralement la façon la plus sécurisée et la plus simple.
    </p>
   </dd>
  </dl>
   <dl class="qandaentry" id="faq.password.storing-salts">
    <dt><strong>
     
      Comment stocker mes salts ?
     
    </strong></dt>
    <dd class="answer">
     <p class="para">
      Lors de l&#039;utilisation de la fonction <span class="function"><a href="function.password-hash.html" class="function">password_hash()</a></span> ou
      de la fonction <span class="function"><a href="function.crypt.html" class="function">crypt()</a></span>, la valeur retournée inclue le salt
      comme parti du hash généré. Cette valeur devrait être stockée telle quelle
      dans votre base de données, sachant qu&#039;elle inclue les informations sur
      la fonction de hashage utilisée et peut donc être fournie directement à
      la fonction <span class="function"><a href="function.password-verify.html" class="function">password_verify()</a></span> ou la fonction
      <span class="function"><a href="function.crypt.html" class="function">crypt()</a></span> lors de la vérification des mots de passe.
     </p>
     <p class="para">
      Le diagramme suivant montre le format d&#039;une valeur retournée
      de la fonction <span class="function"><a href="function.crypt.html" class="function">crypt()</a></span> ou <span class="function"><a href="function.password-hash.html" class="function">password_hash()</a></span>.
      Comme vous pouvez le voir, tout est présent, comme toutes les informations
      sur l&#039;algorithme et le salt nécessaires pour une future vérification
      de mots de passe.
     </p>
     <p class="para">
      <div class="mediaobject">
       
       <div class="imageobject">
        <img src="images/2a34c7f2e658f6ae74f3869f2aa5886f-crypt-text-rendered.svg" alt="
        Les composants de la valeur retournée par la fonction password_hash et crypt :
        dans l'ordre, l'algorithme choisi, les options de l'algorithme, le salt utilisé,
        et le mot de passe hashé.
       " width="690" height="192" />
       </div>
      </div>
     </p>
    </dd>
   </dl>
  
  
 </div>
</div></div></body></html>