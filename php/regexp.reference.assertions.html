<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Assertions</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

 </head>
 <body class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="regexp.reference.back-references.html">« R&eacute;f&eacute;rences arri&egrave;res</a></li>
      <li style="float: right;"><a href="regexp.reference.onlyonce.html">Sous-masques uniques »</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="reference.pcre.pattern.syntax.html">Fonctionnement des expressions rationnelles</a></li>
    <li>Assertions</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="regexp.reference.assertions" class="section">
  <h2 class="title">Assertions</h2>
  <p class="para">
   Une assertion est un test sur les caractères suivants ou
   précédents celui qui est en cours d&#039;étude. Ce
   test ne consomme pas de caractères (ie, on ne déplace
   pas le pointeur de caractères). Les assertions simples sont
   codées avec <code class="literal">\b</code>, <code class="literal">\B</code>,
   <code class="literal">\A</code>, <code class="literal">\Z</code>, <code class="literal">\z</code>,
   <code class="literal">^</code> et <code class="literal">$</code>, et sont décrites
   dans les <a href="regexp.reference.escape.html" class="link">séquences d&#039;échappement</a>.
   Il existe cependant des types d&#039;assertions plus complexes, codées sous la forme
   de sous-masques. Il en existe deux types : celles qui travaillent
   <em class="emphasis">au-delà</em> de la position courante, et celles qui
   travaillent <em class="emphasis">en-deçà</em>.
  </p>
  <p class="para">
   Une assertion se comporte comme un sous-masque, hormis le fait qu&#039;elle
   ne déplace pas le pointeur de position. Les <em class="emphasis">assertions avant</em>
   commencent par <code class="literal">(?=</code> pour les assertions positives, et
   par <code class="literal">(?!</code>, pour les assertions négatives. Par exemple :
   
   <code class="literal">\w+(?=;)</code>
   
   s&#039;assure qu&#039;un mot est suivi d&#039;un point-virgule,
   mais n&#039;inclut pas le point virgule dans la capture et <code class="literal">foo(?!bar)</code>
   trouve toutes les occurrences de &quot;foo&quot; qui ne sont pas suivies par &quot;bar&quot;.
   Notez que,
   
   <code class="literal">(?!foo)bar</code>
   
   en est proche, mais ne trouve pas une
   occurrence de &quot;<code class="literal">bar</code>&quot; qui soit précédée
   par quelque chose d&#039;autre que &quot;<code class="literal">foo</code>&quot;; il
   trouve toutes les occurrences de &quot;<code class="literal">bar</code>&quot;,
   quel que soit ce qui le précède, car l&#039;assertion
   
   <code class="literal">(?!foo)</code>
   
   est toujours vraie quand les trois caractères suivants sont
   &quot;<code class="literal">bar</code>&quot;. Une assertion arrière est ici
   nécessaire.
  </p>
  <p class="para">
   Les <em class="emphasis">assertions</em> arrières commencent par <code class="literal">(?&lt;=</code>
   pour les assertions positives, et <code class="literal">(?&lt;!</code> pour les
   assertions négatives. Par exemple :
   
   <code class="literal">(?&lt;!foo)bar</code>
   
   trouve les occurrences de &quot;<code class="literal">bar</code>&quot; qui ne sont pas
   précédées par &quot;<code class="literal">foo</code>&quot;. Le contenu d&#039;une référence
   arrière est limité de telle façon que les chaînes qu&#039;il utilise
   soient toujours de la même taille. Cependant, lorsqu&#039;il
   y a plusieurs alternatives, elles n&#039;ont pas besoin d&#039;être
   de la même taille. Par exemple,
   
   <code class="literal">(?&lt;=bullock|donkey)</code>
   
   est autorisé, tandis que
   
   <code class="literal">(?&lt;!dogs?|cats?)</code>
   
   provoque une erreur de compilation. Les alternatives qui ont des
   longueurs différentes ne sont autorisées qu&#039;au niveau
   supérieur des assertions arrières. C&#039;est une
   amélioration du fonctionnement de Perl 5.005, qui impose
   aux alternatives d&#039;avoir toutes la même taille. Une
   assertion telle que
   
   <code class="literal">(?&lt;=ab(c|de))</code>
   
   n&#039;est pas autorisée, car l&#039;assertion de bas niveau (la deuxième,
   ici) a deux alternatives de longueurs différentes. Pour
   la rendre acceptable, il faut écrire
   
   <code class="literal">(?&lt;=abc|abde)</code>
   
   L&#039;implémentation des assertions arrières déplace
   temporairement le pointeur de position vers l&#039;arrière, et cherche
   à vérifier l&#039;assertion. Si le nombre de caractères
   est différent, la position ne sera pas correcte, et l&#039;assertion
   échouera. La combinaison d&#039;assertions arrières avec des
   sous-masques peut être particulièrement pratique à
   fin des chaînes. Un exemple est donné à la fin de
   cette section.
  </p>
  <p class="para">
   Plusieurs assertions peuvent intervenir successivement. Par exemple,
   le masque
   
   <code class="literal">(?&lt;=\d{3})(?&lt;!999)foo</code>
   
   recherche les chaînes &quot;<code class="literal">foo</code>&quot; précédées
   par trois chiffres qui ne sont pas &quot;999&quot;. Notez que chaque assertion
   est appliquées indépendamment, au même point de
   la chaîne à traiter. Tout d&#039;abord, il est
   vérifié que les trois premiers caractères ont
   tous des chiffres, puis on s&#039;assure que ces trois caractères
   ne sont pas &quot;<code class="literal">999</code>&quot;. Le masque précédant
   n&#039;accepte pas &quot;<code class="literal">foo</code>&quot; précédé de
   6 caractères, les trois premiers étant des chiffres et
   les trois suivants étant différents de &quot;<code class="literal">999</code>&quot;.
   Par exemple, ce masque n&#039;acceptera pas la chaîne
   &quot;<code class="literal">123abcfoo</code>&quot;. Pour ce faire, il faut utiliser le masque
   suivant :
   
   <code class="literal">(?&lt;=\d{3}...)(?&lt;!999)foo</code>.
   
  </p>
  <p class="para">
   Dans ce masque, la première assertion vérifie les six premiers
   caractères, s&#039;assure que les trois premiers sont des entiers,
   et la deuxième assertion s&#039;assure que les trois derniers
   caractères ne sont pas &quot;<code class="literal">999</code>&quot;.
  </p>
  <p class="para">
   De plus, les assertions peuvent être imbriquées :
   
   <code class="literal">(?&lt;=(?&lt;!foo)bar)baz</code>
   
   recherche les occurrences de &quot;<code class="literal">baz</code>&quot; qui sont
   précédées par &quot;<code class="literal">bar</code>&quot;, qui,
   à son tour, n&#039;est pas précédé par
   &quot;<code class="literal">foo</code>&quot;. Au contraire,
   
   <code class="literal">(?&lt;=\d{3}...(?&lt;!999))foo</code>
   
   est un autre masque, qui recherche les caractères &quot;<code class="literal">foo</code>&quot;,
   précédés par trois chiffres, suivis de trois
   autres caractères qui ne forment pas &quot;<code class="literal">999</code>&quot;.
  </p>
  <p class="para">
   Les assertions ne sont pas capturantes, et ne peuvent pas être
   répétées. Si une assertion contient des sous-masques
   capturants en son sein, ils seront compris dans le nombre de sous-masques
   capturants du masque entier. La capture est réalisée pour
   les assertions positives, mais cela n&#039;a pas de sens pour les
   assertions négatives.
  </p>
  <p class="para">
   200 assertions au maximum sont autorisées.
  </p>
 </div></div></div></body></html>