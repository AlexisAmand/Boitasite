<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Int&eacute;gration du cache</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

 </head>
 <body class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="mysqlnd-ms.gtid.html">« Identifiants de transaction</a></li>
      <li style="float: right;"><a href="mysqlnd-ms.supportedclusters.html">Clusters support&eacute;s »</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="mysqlnd-ms.concepts.html">Concepts</a></li>
    <li>Int&eacute;gration du cache</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="mysqlnd-ms.concept_cache" class="section">
  <h2 class="title">Intégration du cache</h2>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <strong>Version requise</strong><br />
   <p class="para">
    Cette fonctionnalité requière l&#039;utilisation de
    <code class="literal">PECL/mysqlnd_ms</code> 1.3.0-beta ou supérieure et de
    <code class="literal">PECL/mysqlnd_qc</code> 1.1.0-alpha ou supérieure.
    <code class="literal">PECL/mysqlnd_ms</code> doit être compilé pour supporter cette
    fonctionnalité. PHP 5.4.0 ou supérieure est requise.
   </p>
  </p></blockquote>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <strong>Configuration : ordre de chargement de l&#039;extension</strong><br />
   <p class="para">
    <code class="literal">PECL/mysqlnd_ms</code> doit être chargé avant
    <code class="literal">PECL/mysqlnd_qc</code>, lors de l&#039;utilisation des
    extensions partagées.
   </p>
  </p></blockquote>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <strong>Stabilité des fonctionalités</strong><br />
   <p class="para">
    L&#039;intégration du cache est en qualité béta.
   </p>
  </p></blockquote>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <strong>Clusters MySQL appropriés</strong><br />
   <p class="para">
    Cette fonctionnalité est prévue pour une utilisation avec un serveur
    de réplication MySQL (copie primaire). Actuellement, aucun autre type
    de cluster MySQL n&#039;est supporté. Les utilisateurs d&#039;un tel cluster
    doivent contrôler PECL/mysqlnd_qc manuellement s&#039;ils sont intéressés
    dans la mise en cache de requête côté client.
   </p>
  </p></blockquote>
  <p class="para">
   Le support des clusters de réplication MySQL (copie primaire asynchrone)
   est le principal but de <code class="literal">PECL/mysqlnd_ms</code>. Les esclaves d&#039;un cluster de
   réplication MySQL peuvent ou non refléter les dernières mises à jour
   depuis le maître. Les esclaves sont asynchrones, et peuvent lagger derrière
   le maître. Une lecture depuis un esclave a une consistence éventuelle depuis
   une perspective cluster.
  </p>
  <p class="para">
   Le même niveau de consistence est offert par un cache local en utilisant
   une stratégie d&#039;invalidation time-to-live (TTL). Des données courantes ou
   des données non mises à jour peuvent être servies. Eventuellement, les données
   recherchées depuis le cache peuvent ne pas être disponibles et la source
   du cache peut devoir être accédé.
  </p>
  <p class="para">
   En fournissant à la fois un esclage de réplication MySQL (secondaire asynchrone)
   et un cache local TTL, un niveau de service identique est fourni, et il est possible
   de remplacer de façon transparente un accès à une base de données distante par
   un accès au cache local afin d&#039;améliorer les possibilités.
  </p>
  <p class="para">
   Depuis <code class="literal">PECL/mysqlnd_ms</code> 1.3.0-beta, le plugin est capable de contrôler de façon
   transparente <code class="literal">PECL/mysqlnd_ms</code> 1.1.0-alpha ou supérieure pour mettre en cache une
   requête en lecture seule si c&#039;est explicitement autorisé via la configuration
   d&#039;une qualité de service appropriée en utilisant la fonction
   <span class="function"><a href="function.mysqlnd-ms-set-qos.html" class="function">mysqlnd_ms_set_qos()</a></span>. Reportez-vous à la section
   <a href="mysqlnd-ms.quickstart.cache.html" class="link">Démarrage rapide</a> pour un exemple
   de code. Les deux plugins doivent être installés, et <code class="literal">PECL/mysqlnd_ms</code> doit avoir été
   compilé pour supporter la fonctionnalité de cache, et enfin, PHP 5.4.0 ou supérieure
   doit être utilisé.
  </p>
  <p class="para">
   Les applications ont un contrôle total de l&#039;utilisation du cache et peuvent
   demander la mise à jour des données à n&#039;importe quel moment, si besoin.
   L&#039;utilisation du cache peut être activée et désactivé lors de l&#039;exécution
   du script. Le cache sera utilisé si la fonction <span class="function"><a href="function.mysqlnd-ms-set-qos.html" class="function">mysqlnd_ms_set_qos()</a></span>
   définit la qualité de service à une consistence éventuelle, et active
   l&#039;utilisation du cache. L&#039;utilisation du cache est désactivé en demandant un
   niveau de consistence supérieur, par exemple, une consistence de session (lecture
   de vos écritures). Une fois que la qualité de service revient à une consistence
   éventuelle, le cache peut de nouveau être activé.
  </p>
  <p class="para">
   Si la mise en cache est active pour une requête en lecture seule, <code class="literal">PECL/mysqlnd_ms</code>
   peut injecter <a href="mysqlnd-qc.quickstart.caching.html" class="link">une astuce SQL pour contrôler
   la mise en cache</a> via PECL/mysqlnd_qc. Cela va modifier la requête SQL
   récupérée depuis l&#039;application. Les processeurs SQL suivants sont supposés
   ignorer les astuces SQL. Une astuce SQL est un commentaire SQL. Les commentaires
   ne doivent pas être ignorés, par exemple, par le serveur de base de données.
  </p>
  <p class="para">
   Le TTL d&#039;une entrée du cache est calculé pour chaque requête. Les applications
   définissent l&#039;âge maximal des données qu&#039;elles souhaitent récupérer en utilisant
   la fonction <span class="function"><a href="function.mysqlnd-ms-set-qos.html" class="function">mysqlnd_ms_set_qos()</a></span>. L&#039;âge définit une limite supérieure
   approximative en secondes des données pouvant être retournées depuis le maître en
   tenant compte du lag.
  </p>
  <p class="para">
   La logique suivante est utilisée pour calculer le TTL courant si le cache
   est actif. La logique prend en compte le lag estimé de l&#039;esclave pour choisir
   un TTL. Si, par exemple, il y a deux esclaves qui laguent de 5 et 10 secondes
   et que l&#039;âge maximal autorisé est de 60 secondes, le TTL sera défini à 50 secondes.
   Notez également que la définission de l&#039;âge ne dépassera pas le calcul estimé.
   <ul class="itemizedlist">
    <li class="listitem">
     <span class="simpara">
      Vérifie si la requête est une requête en lecture seule. Si ce n&#039;est pas le cas,
      aucune mise en cache ne sera demandée.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Si le cache est actif, vérifie si le lag de tous les serveurs esclaves configurés.
      Etablissement des connexions aux esclaves si aucune n&#039;existe et que les connexions
      paresseuses sont utilisées.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Envoi <code class="literal">SHOW SLAVE STATUS</code> à tous les esclaves. N&#039;attends pas
      que le premier esclave réponde avant d&#039;envoyer la demande au second.
      Les clients attendent souvent longtemps, aussi, tout est envoyé en même temps
      et l&#039;analyse se fera dans un second temps.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      On parcourt tous les esclaves. Pour chaque esclave, on attend sa réponse.
      On ne commence pas l&#039;analyse du prochain esclave avant que le courant n&#039;ait
      répondu. On vérifie <code class="literal">Slave_IO_Running=Yes</code> et <code class="literal">Slave_SQL_Running=Yes</code>.
      Si les deux conditions sont vraies, on récupère la valeur de
      <code class="literal">Seconds_Behind_Master</code>. Dans le cas d&#039;une erreur, ou d&#039;un échec sur
      l&#039;une des conditions, on définit une erreur sur la connexion de l&#039;esclave.
      Cela permet d&#039;ignorer ces connexions pour le reste du filtrage de connexion.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Recherche de la valeur maximale de <code class="literal">Seconds_Behind_Master</code>
      depuis tous les esclaves qui ont passés les conditions précédentes.
      On soustrait la valeur depuis l&#039;âge maximal fourni par l&#039;utilisateur avec 
      la fonction <span class="function"><a href="function.mysqlnd-ms-set-qos.html" class="function">mysqlnd_ms_set_qos()</a></span>. Le reste de cette soustraction
      sera utilisé comme TTL.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Ce filtrage va trier tous les esclaves. Ainsi, l&#039;âge maximal est utilisé
      comme TTL, car le lag maximal trouvé vaut zéro. Il est tout à fait valide
      de trier tous les esclaves. Le filtre de balance de charge interne
      prendra le maître.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Injection des astuces SQL appropriées pour activer la mise en cache par <code class="literal">PECL/mysqlnd_qc</code>.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Traitement avec la connexion filtrée, i.e. applique les règles de balance
      de charge pour récupérer un esclave.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      <code class="literal">PECL/mysqlnd_qc</code> est chargé après
      <code class="literal">PECL/mysqlnd_ms</code> par PHP. Aussi, il verra toutes
      les modifications de requêtes de <code class="literal">PECL/mysqlnd_ms</code>
      et mettra en cache la requête s&#039;il en a reçu l&#039;instruction.
     </span>
    </li>
   </ul>
  </p>
  <p class="para">
   L&#039;algorithme peut paraître impressionnant. <code class="literal">SHOW SLAVE STATUS</code> est une
   opération très rapide.En considérant un nombre de requêtes suffisants et les accès
   au cache par seconde, le coût de la vérification du lag des esclaves est largement
   inférieur au coût d&#039;une décision du cache.
  </p>
  <p class="para">
   Les suggestions sur un meilleur algorithme sont bien entendues les bienvenues.
  </p>
 </div></div></div></body></html>