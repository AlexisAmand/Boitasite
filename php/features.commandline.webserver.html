<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Serveur web interne</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

 </head>
 <body class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="features.commandline.interactive.html">« Shell Interactif</a></li>
      <li style="float: right;"><a href="features.commandline.ini.html">Configurations INI »</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="features.commandline.html">Utilisation des lignes de commande</a></li>
    <li>Serveur web interne</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="features.commandline.webserver" class="section">
  <h2 class="title">Serveur web interne</h2>
  
  <div class="warning"><strong class="warning">Avertissement</strong>
   <p class="para">
    Ce serveur web est prévu pour aider dans le développement des applications.
    Il peut également être utile pour les tests, et pour les démonstrations
    d&#039;applications qui sont exécutées dans des environnements contrôlés.
    Mais par contre, il n&#039;a pas été conçu pour être un serveur web complet.
    Aussi, il ne devrait pas être utilisé dans un réseau public.
   </p>
  </div>
  
  <p class="para">
   Depuis PHP 5.4.0, le <acronym title="Command Line Interpreter/Interface">CLI</acronym> <acronym title="Server Application Programming Interface">SAPI</acronym> fournit un serveur web interne.
  </p>
  
  <p class="para">
   Le serveur web s&#039;exécute sur un seul processus single-threaded,
   les applications PHP seront retardés/suspendues si une requête est bloquée.
  </p>
  
  <p class="para">
   Les requêtes URI sont servies depuis le dossier de travail courant
   où PHP a été démarré, à moins que l&#039;option -t ne soit utilisée pour spécifier
   explicitement un document racine. Si une requête URI ne spécifie
   pas un fichier, alors le fichier index.php ou le fichier
   index.html du dossier courant sera retourné. Si aucun de ces fichiers n&#039;existe,
   la recherche d&#039;un fichier index.php et index.html se poursuivra dans le dossier
   parent et ainsi de suite jusqu&#039;à ce qu&#039;un de ces fichier ne soit trouvé ou
   que le dossier racine ne soit atteint. Si un fichier index.php ou index.html
   est trouvé, il sera retourné et $_SERVER[&#039;PATH_INFO&#039;] sera défini comme la
   dernière partie de l&#039;URI. Sinon, un code réponse 404 sera retourné.
  </p>
  
  <p class="para">
   Si un fichier PHP est fourni dans la ligne de commande lorsque le serveur web
   est démarré, il sera traité comme un script &quot;routeur&quot;.
   Le script sera exécuté au début de chaque requête HTTP. Si ce script retourne
   <strong><code>FALSE</code></strong>, alors la ressource demandée est retournée telle quelle.
   Sinon, la sortie du script est retournée au navigateur.
  </p>

  <p class="para">
    Les types MIME standards sont retournés pour les fichiers avec les
    extensions : .3gp, 
    .apk, .avi, .bmp, .css, .csv, .doc, .docx, .flac, .gif, .gz,
    .gzip, .htm, .html, .ics, .jpe, .jpeg, .jpg, .js, .kml, .kmz,
    .m4a, .mov, .mp3, .mp4, .mpeg, .mpg, .odp, .ods, .odt, .oga, .ogg,
    .ogv, .pdf, .pdf, .png, .pps, .pptx, .qt, .svg, .swf, .tar, .text,
    .tif, .txt, .wav, .webm, .wmv, .xls, .xlsx, .xml, .xsl, .xsd, and .zip.
  </p>


  <table class="doctable table">
   <caption><strong>
    Historique des modifications : Les  types MIME standards (extensions de 
    fichiers)
   </strong></caption>
   
    <thead>
     <tr>
      <th>Version</th>
      <th>Description</th>
     </tr>

    </thead>

    <tbody class="tbody">
     <tr>
      <td>5.5.12</td>
      <td>
       .xml, .xsl, and .xsd
      </td>
     </tr>

     <tr>
      <td>5.5.7</td>
      <td>
       .3gp, .apk, .avi, .bmp, .csv, .doc, .docx, .flac, .gz, .gzip,
       .ics, .kml, .kmz, .m4a, .mp3, .mp4, .mpg, .mpeg, .mov, .odp, .ods,
       .odt, .oga, .pdf, .pptx, .pps, .qt, .swf, .tar, .text, .tif, .wav,
       .wmv, .xls, .xlsx, and .zip
      </td>
     </tr>

     <tr>
      <td>5.5.5</td>
      <td>
       .pdf
      </td>
     </tr>

     <tr>
      <td>5.4.11</td>
      <td>
       .ogg, .ogv, and .webm
      </td>
     </tr>

     <tr>
      <td>5.4.4</td>
      <td>
        .htm and .svg
      </td>
     </tr>

    </tbody>
   
  </table>



  <table class="doctable table">
   <caption><strong>Changelog</strong></caption>
   
    <thead>
     <tr>
      <th>Version</th>
      <th>Description</th>
     </tr>

    </thead>

    <tbody class="tbody">
     <tr>
      <td>7.4.0</td>
      <td>
       Le serveur web intégré peut être configuré pour fork en de multiple
       workers pour tester du code qui nécéssite plusieurs requêtes concurrentes
       au serveur web intégré. Définir la variable d&#039;environnement
       <var class="envar">PHP_CLI_SERVER_WORKERS</var> au nombre désiré de workers avant
       de démarrer le serveur. Ceci n&#039;est pas supporté sous Windows.
       <div class="warning"><strong class="warning">Avertissement</strong>
        <p class="para">
         Ce comportement <em class="emphasis">expérimental</em> <em class="emphasis">n&#039;est pas</em>
         prévu pour un usage en production. Plus générallement, le serveur web intégré
         <em class="emphasis">n&#039;est pas</em> prévu pour un usage en production.
        </p>
       </div>
      </td>
     </tr>

    </tbody>
   
  </table>

  
  <div class="example" id="example-437">
   <p><strong>Exemple #1 Démarrage du serveur web</strong></p> 
   <div class="example-contents">
<div class="shellcode"><pre class="shellcode">$ cd ~/public_html
$ php -S localhost:8000</pre>
</div>
   </div>

   <div class="example-contents"><p>
    Le terminal affichera :
   </p></div>
   <div class="example-contents screen">
<div class="cdata"><pre>
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit
</pre></div>
   </div>
   <div class="example-contents"><p>
    Après des requêtes URI sur http://localhost:8000/ et
    http://localhost:8000/myscript.html, le terminal affichera quelques choses
    comme :
   </p></div>
   <div class="example-contents screen">
<div class="cdata"><pre>
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit.
[Thu Jul 21 10:48:48 2011] ::1:39144 GET /favicon.ico - Request read
[Thu Jul 21 10:48:50 2011] ::1:39146 GET / - Request read
[Thu Jul 21 10:48:50 2011] ::1:39147 GET /favicon.ico - Request read
[Thu Jul 21 10:48:52 2011] ::1:39148 GET /myscript.html - Request read
[Thu Jul 21 10:48:52 2011] ::1:39149 GET /favicon.ico - Request read
</pre></div>
   </div>
   <div class="example-contents"><p>
    Noter qu&#039;avant PHP 7.4.0, les ressources statiques en lien symbolique
    ne sont pas accessibles sous Windows, tant que le script routeur
    ne le gère pas.
   </p></div>
  </div>
  
  <div class="example" id="example-438">
   <p><strong>Exemple #2 Démarrage avec un dossier racine spécifique</strong></p> 
   <div class="example-contents">
<div class="shellcode"><pre class="shellcode">$ cd ~/public_html
$ php -S localhost:8000 -t foo/</pre>
</div>
   </div>

   <div class="example-contents"><p>
    Le terminal affichera :
   </p></div>
   <div class="example-contents screen">
<div class="cdata"><pre>
PHP 5.4.0 Development Server started at Thu Jul 21 10:50:26 2011
Listening on localhost:8000
Document root is /home/me/public_html/foo
Press Ctrl-C to quit
</pre></div>
   </div>
  </div>
  
  <div class="example" id="example-439">
   <p><strong>Exemple #3 Utilisation d&#039;un script routeur</strong></p> 
   <div class="example-contents"><p>
    Dans cet exemple, le fait de demander des images les affichera,
    mais les requêtes pour les fichiers HTML afficheront
    &quot;Bienvenue chez PHP !&quot;.
   </p></div>
   <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">//&nbsp;router.php<br /></span><span style="color: #007700">if&nbsp;(</span><span style="color: #0000BB">preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">'/\.(?:png|jpg|jpeg|gif)$/'</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$_SERVER</span><span style="color: #007700">[</span><span style="color: #DD0000">"REQUEST_URI"</span><span style="color: #007700">]))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;</span><span style="color: #0000BB">false</span><span style="color: #007700">;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #FF8000">//&nbsp;retourne&nbsp;la&nbsp;requête&nbsp;telle&nbsp;quelle.<br /></span><span style="color: #007700">}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #DD0000">"&lt;p&gt;Bienvenue&nbsp;chez&nbsp;PHP&nbsp;!&lt;/p&gt;"</span><span style="color: #007700">;<br />}<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
   </div>

   <div class="example-contents">
<div class="shellcode"><pre class="shellcode">$ php -S localhost:8000 router.php</pre>
</div>
   </div>

  </div>
  
  <div class="example" id="example-440">
   <p><strong>Exemple #4 Vérification de l&#039;utilisation CLI du serveur Web</strong></p>
   <div class="example-contents"><p>
    Pour ré-utiliser un script router du framework lors du
    développement avec le CLI du serveur web et ensuite, continuez
    de l&#039;utiliser avec un serveur web de production :
   </p></div>
   <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">//&nbsp;router.php<br /></span><span style="color: #007700">if&nbsp;(</span><span style="color: #0000BB">php_sapi_name</span><span style="color: #007700">()&nbsp;==&nbsp;</span><span style="color: #DD0000">'cli-server'</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #FF8000">/*&nbsp;Activation&nbsp;de&nbsp;la&nbsp;route&nbsp;statique&nbsp;et&nbsp;retourne&nbsp;FALSE&nbsp;*/<br /></span><span style="color: #007700">}<br /></span><span style="color: #FF8000">/*&nbsp;on&nbsp;continue&nbsp;avec&nbsp;les&nbsp;opérations&nbsp;d'un&nbsp;index.php&nbsp;normal&nbsp;*/<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
   </div>

   <div class="example-contents">
<div class="shellcode"><pre class="shellcode">$ php -S localhost:8000 router.php</pre>
</div>
   </div>

  </div>
  
  <div class="example" id="example-441">
   <p><strong>Exemple #5 Gestion des types de fichiers non supportés</strong></p> 
   <div class="example-contents"><p>
    Si vous devez servir une ressource statique pour laquelle le type
    MIME n&#039;est pas géré par le CLI du serveur web, utilisez ceci :
   </p></div>
   <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">//&nbsp;router.php<br /></span><span style="color: #0000BB">$path&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">pathinfo</span><span style="color: #007700">(</span><span style="color: #0000BB">$_SERVER</span><span style="color: #007700">[</span><span style="color: #DD0000">"SCRIPT_FILENAME"</span><span style="color: #007700">]);<br />if&nbsp;(</span><span style="color: #0000BB">$path</span><span style="color: #007700">[</span><span style="color: #DD0000">"extension"</span><span style="color: #007700">]&nbsp;==&nbsp;</span><span style="color: #DD0000">"el"</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000BB">header</span><span style="color: #007700">(</span><span style="color: #DD0000">"Content-Type:&nbsp;text/x-script.elisp"</span><span style="color: #007700">);<br />&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000BB">readfile</span><span style="color: #007700">(</span><span style="color: #0000BB">$_SERVER</span><span style="color: #007700">[</span><span style="color: #DD0000">"SCRIPT_FILENAME"</span><span style="color: #007700">]);<br />}<br />else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;</span><span style="color: #0000BB">FALSE</span><span style="color: #007700">;<br />}<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
   </div>

   <div class="example-contents">
<div class="shellcode"><pre class="shellcode">$ php -S localhost:8000 router.php</pre>
</div>
   </div>

  </div>
  
  <div class="example" id="example-442">
   <p><strong>Exemple #6 Accès au CLI du serveur web depuis une machine distante</strong></p> 
   <div class="example-contents"><p>
    Vous pouvez rendre le serveur web accessible sur le port 8000
    pour toutes les interfaces avec :
   </p></div>
   <div class="example-contents">
<div class="shellcode"><pre class="shellcode">$ php -S 0.0.0.0:8000</pre>
</div>
   </div>

   <div class="warning"><strong class="warning">Avertissement</strong>
    <p class="para">
     Le serveur web intégré ne doit pas être utilisé sur un réseau public.
    </p>
   </div>
  </div>
  
 </div></div></div></body></html>