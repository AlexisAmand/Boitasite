<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Architecture et conceptes</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

 </head>
 <body class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="mysqlnd-qc.quickstart.html">« D&eacute;marrage rapide et quelques exemples</a></li>
      <li style="float: right;"><a href="mysqlnd-qc.quickstart.configuration.html">Configuration »</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="mysqlnd-qc.quickstart.html">D&eacute;marrage rapide et quelques exemples</a></li>
    <li>Architecture et conceptes</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="mysqlnd-qc.quickstart.concepts" class="section">
  <h2 class="title">Architecture et conceptes</h2>
  <p class="para">
   Le plugin de mise en cache de requêtes est implémenté comme une extension PHP.
   Il est écrit en C et opère en dessous de PHP. Lors du démarrage
   de l&#039;interpréteur PHP, il est enregistré comme un plugin
   <a href="book.mysqlnd.html" class="link">mysqlnd</a> pour remplacer les méthodes
   sélectionnées de mysqlnd C. Ainsi, il peut modifier le comportement
   de n&#039;importe quelle extension PHP MySQL (<a href="ref.mysqli.html" class="link">mysqli</a>,
   <a href="ref.pdo-mysql.html" class="link">PDO_MYSQL</a>,
   <a href="ref.mysql.html" class="link">mysql</a>) compilée pour utiliser la bibliothèque
   mysqlnd sans modification de l&#039;API de l&#039;extension. Ceci rend le plugin
   compatible avec toutes les applications PHP MySQL. En raison du fait que
   l&#039;API n&#039;est pas modifiée, son utilisation est totalement transparente.
   Reportez-vous à la
   <a href="mysqlnd.plugin.html" class="link">description de l&#039;API plugin de mysqlnd</a>
   pour plus de détails sur les avantages de l&#039;architecture plugin et une
   comparaison avec les solutions basées sur les proxy.
  </p>
  <p class="para">
   <em class="emphasis">Utilisation transparente</em>
  </p>
  <p class="para">
   Lors de l&#039;exécution de PHP, PECL/mysqlnd_qc peut réagir comme un proxy
   pour les requêtes émises depuis PHP
   (<a href="book.mysqlnd.html" class="link">mysqlnd</a>) vers le serveur MySQL.
   Il inspecte la chaîne de requête pour décider si les résultats doivent
   être mis en cache ou non. Si c&#039;est le cas, le jeu de résultats est mis
   en cache en utilisant un gestionnaire de stockage et les futures
   exécutions de cette requête seront servies depuis le cache pour une période
   définie par l&#039;utilisateur. La durée de vie, ou TTL de l&#039;entrée du cache
   peut être soit déterminée de façon globale, soit pour chaque requête.
  </p>
  <p class="para">
   Une requête est soit mise en cache si il est demandé au plugin de mettre
   en cache de façon globale toutes les requêtes, soit si la chaîne de requête
   comme avec une astuce SQL (<code class="literal">/*qc=on*/</code>). Le plugin est capable
   de mettre en cache n&#039;importe quelle requête soumise par un appel approprié
   de l&#039;API depuis n&#039;importe quelle extension PHP MySQL.
  </p>
  <p class="para">
   <em class="emphasis">Stockage flexible : divers gestionnaires de stockage</em>
  </p>
  <p class="para">
   Divers gestionnaires de stockage sont supportés pour offrir différents scopes
   pour les entrées du cache. Les différents scopes autorisent différents degrés
   dans le partage des entrées du cache entre les clients.
  </p>
  <p class="para">
   <ul class="itemizedlist">
    <li class="listitem">
     <p class="para">
      <code class="literal">default</code> (interne) :  processus mémoire, scope : une ou plusieurs requêtes
      suivant le modèle de déployement de PHP utilisé
      </p>
     </li>
     <li class="listitem">
      <p class="para">
       <code class="literal">APC</code> : mémoire partagée, scope : un seul serveur, plusieurs requêtes web
      </p>
     </li>
     <li class="listitem">
      <p class="para">
       <code class="literal">SQLite</code> : en mémoire ou dans un fichier, scope : un seul serveur, plusieurs
       requêtes web
      </p>
     </li>
     <li class="listitem">
      <p class="para">
       <code class="literal">MEMCACHE</code> : mémoire principale, scope : un ou plusieurs serveurs, plusieurs
       requêtes web
      </p>
     </li>
     <li class="listitem">
      <p class="para">
       <code class="literal">user</code> (interne) : défini par l&#039;utilisateur, scope : défini par l&#039;utilisateur
      </p>
     </li>
    </ul>
  </p>
  <p class="para">
   Le support des gestionnaires de stockage <code class="literal">APC</code>, <code class="literal">SQLite</code>
   et <code class="literal">MEMCACHE</code> doit être activé lors de la compilation. Le gestionnaire
   <code class="literal">default</code> et <code class="literal">user</code> sont internes. Il est possible
   de passer d&#039;un gestionnaire compilé de stockage à l&#039;autre à chaque requête lors de l&#039;exécution.
   Cependant, il est recommandé de prendre un gestionnaire de stockage et de l&#039;utiliser
   pour toutes les entrées du cache.
  </p>
  <p class="para">
   <em class="emphasis">Défense de type slam interne afin de prévenir une surcharge</em>
  </p>
  <p class="para">
   Pour prévenir des situations de surcharge, le plugin de mise en cache a un mécanisme
   de défense de type slam en interne. Si une entrée populaire du cache expire,
   plusieurs clients utilisant les entrées du cache tenteront de mettre à jour l&#039;entrée
   du cache. Pendant la durée de se rafraîchissement, plusieurs clients peuvent
   accéder au serveur de base de données de façon concurrente. Dans la plupart des cas,
   le serveur de base de données devient surchargé et il prendra de plus en plus de temps
   à mettre à jour l&#039;entrée du cache, car il recevra de plus en plus de clients
   qui tenteront de mettre à jour l&#039;entrée du cache. Pour prévenir ce comportement,
   le plugin a un mécanisme de défense de type slam. Si il est activé et que le plugin
   détecte l&#039;expiration d&#039;une entrée du cache, il va étendre la durée de vie de cette entrée
   avant de la mettre à jour. De cette façon, les autres accès concurrents à cette entrée
   du cache seront toujours servis depuis le cache pour un certain temps. Ainsi,
   les accès concurrents ne vont pas tous provoquer des mises à jour concurrentes.
   Idéalement, l&#039;entrée du cache sera mise à jour par le client en étendant sa durée
   de vie avant que d&#039;autres clients ne tentent de mettre à jour le cache, et potentiellement,
   éviter ainsi une situation de surcharge.
  </p>
  <p class="para">
   <em class="emphasis">Approche unique dans la mise en cache</em>
  </p>
  <p class="para">
   PECL/mysqlnd_qc a une approche unique dans la mise en cache des jeux de résultats
   qui est supérieure aux solutions de mise en cache des applications. Les solutions
   applicatives commencent par récupérer un jeu de résultats dans des variables
   PHP. Puis, les variables PHP sont linéarisées pour stockage dans un cache persistent
   et délinéarisées lors de la récupération. La mise en cache de requête mysqlnd
   stocke les données brutes du protocole envoyées depuis MySQl vers PHP dans son
   cache, et les retournent, si elles sont toujours valides, lors d&#039;une demande d&#039;accès.
   De cette façon, elle échappe à une étape de linéarisation pour une mise en cache
   que toutes les solutions applicatives doivent réaliser. Le plugin peut stocker les
   données brutes du protocole en cache sans avoir à les linéariser en variable PHP
   dans un premier temps, et de les délinéariser en variable PHP pour le
   stockage en cache une nouvelle fois.
  </p>
 </div></div></div></body></html>